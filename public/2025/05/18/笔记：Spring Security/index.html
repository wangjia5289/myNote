

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/ba.jpg">
  <link rel="icon" href="/img/ba.jpg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#373737">
  <meta name="author" content="霸天">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、理论1. 导图  2. Spring Security 执行流程1. 用户请求（客户端请求）每次用户访问受 Spring Security 保护的资源，都会经过以下流程 2. SecurityContextPersistenceFilter 介入自动为本线程初始化 SecurityContextHolder 并根据 JSESSIONID 向 HttpSession 查找 SecurityCon">
<meta property="og:type" content="article">
<meta property="og:title" content="笔记：Spring Security">
<meta property="og:url" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9ASpring%20Security/index.html">
<meta property="og:site_name" content="夜阑卧听风吹雨,一枝梨花压心头">
<meta property="og:description" content="一、理论1. 导图  2. Spring Security 执行流程1. 用户请求（客户端请求）每次用户访问受 Spring Security 保护的资源，都会经过以下流程 2. SecurityContextPersistenceFilter 介入自动为本线程初始化 SecurityContextHolder 并根据 JSESSIONID 向 HttpSession 查找 SecurityCon">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://wangjia5289.github.io/source/_posts/%E7%AC%94%E8%AE%B0%EF%BC%9ASpring%20Security/Map%EF%BC%9ASpringSecurity.xmind">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9ASpring%20Security/image-20250628224744251.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9ASpring%20Security/image-20250628210023140.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9ASpring%20Security/image-20250630183241212.png">
<meta property="article:published_time" content="2025-05-17T16:00:00.000Z">
<meta property="article:modified_time" content="2025-07-14T01:23:08.176Z">
<meta property="article:author" content="Ba Tian">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://wangjia5289.github.io/source/_posts/%E7%AC%94%E8%AE%B0%EF%BC%9ASpring%20Security/Map%EF%BC%9ASpringSecurity.xmind">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>笔记：Spring Security - 夜阑卧听风吹雨,一枝梨花压心头</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"wangjia5289.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%85%89%E5%BD%B1%E7%BE%8E%E5%AD%A6-%E5%90%8A%E5%B8%A6%E8%A3%99.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="笔记：Spring Security"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-18 00:00" pubdate>
          May 18, 2025 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          153 mins
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        

      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">笔记：Spring Security</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    Last updated on 2025-07-14T09:23:08+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="一、理论"><a href="#一、理论" class="headerlink" title="一、理论"></a>一、理论</h1><h2 id="1-导图"><a href="#1-导图" class="headerlink" title="1. 导图"></a>1. 导图</h2><p><img src="/source/_posts/%E7%AC%94%E8%AE%B0%EF%BC%9ASpring%20Security/Map%EF%BC%9ASpringSecurity.xmind" srcset="/img/loading.gif" lazyload></p>
<hr>
<h2 id="2-Spring-Security-执行流程"><a href="#2-Spring-Security-执行流程" class="headerlink" title="2. Spring Security 执行流程"></a>2. Spring Security 执行流程</h2><p><font color="#92d050">1. 用户请求（客户端请求）</font><br>每次用户访问受 <code>Spring Security</code> 保护的资源，都会经过以下流程</p>
<p><font color="#92d050">2. SecurityContextPersistenceFilter 介入</font><br>自动为本线程初始化 <code>SecurityContextHolder</code> 并根据 <code>JSESSIONID</code> 向 <code>HttpSession</code> 查找 <code>SecurityContext</code>（其内保存最重要的 <code>Authentication</code>）</p>
<ol>
<li>若存在 <code>SecurityContext</code>，便将其加载到本线程的 <code>SecurityContextHolder</code> 中（基于 HttpSession 实现 “记住我” 功能，我们也可基于 JWT 实现 “记住我” 功能）</li>
<li>若不存在 <code>SecurityContext</code>，则在本线程中自动初始化一个新的 <code>SecurityContext</code></li>
</ol>
<p>即使我们不打算通过 <code>HttpSession</code> 实现 “记住我” 功能（如使用 JWT），甚至完全不使用 <code>HttpSession</code>，我们仍然建议保留这个过滤器，因为它自动为本线程初始化 <code>SecurityContextHolder</code>、并自动创建 <code>SecurityContext</code>，这个能力实在太香了。<br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9ASpring%20Security/image-20250628224744251.png" srcset="/img/loading.gif" lazyload></p>
<p><font color="#92d050">2. RememberMeAuthenticationFilter 介入（需开启）</font></p>
<ul>
<li><p>当用户访问时，如果当前 <code>SecurityContext</code> 里没有认证信息（没登录），</p>
</li>
<li><p>它会检查请求中的 RememberMe Cookie，</p>
</li>
<li><p>如果 Cookie 有效且合法，它会自动创建一个认证信息（<code>Authentication</code>），</p>
</li>
<li><p>把这个认证信息放入 <code>SecurityContext</code>，</p>
</li>
<li><p>从而让用户“自动登录”，不必重新输入用户名密码。</p>
</li>
</ul>
<p>sessionManagementFilter 过滤器介入</p>
<p><font color="#92d050">3. CsrfFilter 介入</font><br>该过滤器会尝试从我们配置的 CSRF Token 存储位置（配置的 <code>HttpSessionCsrfTokenRepository</code>）中加载 CSRF Token，且所有请求都会经过这一尝试。若成功加载，Token 会被放入 <code>HttpServletRequest</code> 中；如果未加载到，则会创建一个新的 CSRF Token，并同样放入请求中。</p>
<p>对于启用 CSRF 防护的路径，当执行修改服务器状态的敏感操作（如 POST、PUT、DELETE、PATCH 等）时，过滤器会检查前端是否在指定的位置（配置的 <code>.setHeaderName(&quot;X-CSRF-TOKEN&quot;)</code> 等位置）携带了 Token。若未携带，则抛出 <code>MissingCsrfTokenException</code>；若携带，则会将前端 Token 与 <code>HttpServletRequest</code> 中的 Token 进行比对，匹配则继续执行，不匹配则抛出 <code>InvalidCsrfTokenException</code>。</p>
<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>CSRF 相关的异常都是 <code>AccessDeniedException</code> 的子类，所以我们应该在处理 <code>AccessDeniedException</code> 时处理这两个异常</li>
</ol>
</blockquote>
<p><font color="#92d050">4. UsernamePasswordAuthenticationFilter 介入</font><br>该过滤器主要用于前后端未分离的场景，用于处理默认 <code>/login</code> 路径下的登录请求。  </p>
<p>在前后端分离的架构中无需深入关注其具体逻辑，只需了解其在过滤器链中的位置，以便在插入自定义过滤器时能准确定位。</p>
<p>该过滤器用于拦截我们处理登陆表单的提交请求的端点，也就是我们在表单登录中配置的 <code>form.loginProcessingUrl(&quot;/login&quot;)</code> ，他会读取请求参数中的用户名和密码（默认名是 <code>username</code> 和 <code>password</code>），自动将其封装为UsernamePasswordAuthenticationToken调用 <code>AuthenticationManager.authenticate(...)</code> 进行认证如果认证成功会自动将 AuthenticationManager 返回的 Authentication 存入到本线程的 <code>SecurityContext</code>（我们自定义的登录操作，使用authenticationmanager，就少了这一步而已）。保存用户信息并执行我们在表单登录 中配置的form.defaultSuccessUrl、form.successHandler</p>
<p><font color="#92d050">LogoutFilter 介入</font></p>
<ul>
<li><p>清空 <code>SecurityContext</code> 中的认证信息（相当于“登出”）</p>
</li>
<li><p>使当前 HTTP Session 失效（<code>HttpSession.invalidate()</code>）</p>
</li>
<li><p>清理相关的 RememberMe Cookie（如果配置了 RememberMe）</p>
</li>
<li><p>重定向到退出后的默认页面，默认是重定向到登录页 <code>/login?logout</code></p>
</li>
</ul>
<p><font color="#92d050">5. AnonymousAuthenticationFilter 介入</font><br>如果当前没有任何 <code>Authentication</code>，系统会自动创建一个匿名身份，以避免后续流程中出现空指针异常。</p>
<p><font color="#92d050">6. ExceptionTranslationFilter 介入</font></p>
<p><font color="#92d050">6. FilterSecurityInterceptor 介入</font><br>首先检查当前线程中是否存在 <code>Authentication</code>（无论是否为匿名身份），如果不存在，则抛出 <code>AuthenticationException</code>，表示用户尚未进行认证。</p>
<p>接着判断是否为匿名用户访问受保护资源：即若用户尚未认证（即为匿名身份 <code>Authentication</code>），且访问的资源未被标注为 <code>permitAll</code>，则抛出 <code>AuthenticationException</code> 异常。</p>
<p>最后检查当前用户是否具备访问目标资源或方法的权限（包括资源级别和方法级别的访问控制），若权限不足，则抛出 <code>AccessDeniedException</code>。</p>
<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>整个流程中的异常由 <code>ExceptionTranslation</code> 过滤器统一处理，负责捕获<strong>整个过滤器链中</strong>抛出的 <code>AuthenticationException</code> 和 <code>AccessDeniedException</code> 异常，并执行相应的处理逻辑。</li>
</ol>
</blockquote>
<p><font color="#92d050">7. 执行 API</font><br>在这一步，才真正开始执行我们的 API 逻辑；如果是登录 API，并且通过 AuthenticationManager 进行认证，流程如下：<br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9ASpring%20Security/image-20250628210023140.png" srcset="/img/loading.gif" lazyload></p>
<p><font color="#92d050">8. SecurityContextPersistenceFilter 再次介入</font><br>它会自动将本线程的 <code>SecurityContext</code> 存入服务器的 <code>HttpSession</code>，以便在后续请求中维持用户身份（需要手动开启）</p>
<p> 随后，过滤器会清空本线程 <code>SecurityContextHolder</code>，防止 <code>SecurityContext</code> 在后续请求中被无意复用，从而确保每个请求都能独立执行认证和授权流程。</p>
<hr>
<h2 id="3-Spring-Security-配置"><a href="#3-Spring-Security-配置" class="headerlink" title="3. Spring Security 配置"></a>3. Spring Security 配置</h2><h3 id="3-1-Spring-Security-配置模板"><a href="#3-1-Spring-Security-配置模板" class="headerlink" title="3.1. Spring Security 配置模板"></a>3.1. Spring Security 配置模板</h3><p>Spring Security 的配置主要在 Java 配置类中进行，而不是在 <code>application.yml</code> 文件中，因为安全配置通常涉及到逻辑和条件判断，这些无法简单地通过属性文件表达，我们可以完成以下配置：</p>
<p>SecurityConfiguration 类在 <code>com.example.securitywithhttpsession.configuration</code> 包下，直接粘贴这份配置模板，再根据下方的详细说明按需进行调整。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableMethodSecurity</span> <span class="hljs-comment">// 1. 启用方法级别的访问控制</span><br><span class="hljs-meta">@EnableWebSecurity</span> <span class="hljs-comment">// 2. 启用 Spring Security 安全机制</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfiguration</span> </span>&#123;<br><br>    <span class="hljs-comment">// 详见下文：配置 CSRF 攻击防护（配置 CsrfFilter 过滤器）</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">CsrfTokenRepository <span class="hljs-title">csrfTokenRepository</span><span class="hljs-params">()</span> </span>&#123;<br><br>        HttpSessionCsrfTokenRepository repository = <span class="hljs-keyword">new</span> HttpSessionCsrfTokenRepository(); <span class="hljs-comment">// CSRF Token 生成与加载的位置，这里是生成并保存在 HttpSession 中，并从 HttpSession 中加载</span><br><br>        repository.setHeaderName(<span class="hljs-string">&quot;X-CSRF-TOKEN&quot;</span>); <span class="hljs-comment">// 前端可在 X-CSRF-TOKEN 请求头中携带 CSRF Token</span><br>        repository.setParameterName(<span class="hljs-string">&quot;_csrfToken&quot;</span>); <span class="hljs-comment">// 前端可在 _csrfToken 请求体中携带 CSRF Token</span><br>        <span class="hljs-keyword">return</span> repository;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 配置 CORS 跨域资源共享</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">CorsConfigurationSource <span class="hljs-title">corsConfigurationSource</span><span class="hljs-params">()</span> </span>&#123;<br><br>        CorsConfiguration configuration = <span class="hljs-keyword">new</span> CorsConfiguration();<br>        configuration.setAllowedOrigins(List.of(<span class="hljs-string">&quot;http://frontend.example.com&quot;</span>, <span class="hljs-string">&quot;http://localhost:3000&quot;</span>));<br>        configuration.setAllowedOriginPatterns(List.of(<span class="hljs-string">&quot;http://*.example.com&quot;</span>));<br>        configuration.setAllowedMethods(List.of(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>, <span class="hljs-string">&quot;OPTIONS&quot;</span>));<br>        configuration.setAllowedHeaders(List.of(<span class="hljs-string">&quot;*&quot;</span>));<br>        configuration.setAllowCredentials(<span class="hljs-keyword">true</span>);<br><br>        UrlBasedCorsConfigurationSource source = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();<br>        Map&lt;String, CorsConfiguration&gt; configMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        configMap.put(<span class="hljs-string">&quot;/api/**&quot;</span>, configuration);<br>        configMap.put(<span class="hljs-string">&quot;/admin/**&quot;</span>, configuration);<br>        source.setCorsConfigurations(configMap);<br><br>        <span class="hljs-keyword">return</span> source;<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 配置 AuthenticationManager</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">(AuthenticationConfiguration authenticationConfiguration)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> authenticationConfiguration.<span class="hljs-title">getAuthenticationManager</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 从 Spring Security 配置中获取其默认的 AuthenticationManager 实例</span><br>    &#125;<br><br>    <span class="hljs-comment">// 5. 配置 密码加密器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> NoOpPasswordEncoder.<span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 返回合适的实现类</span><br>    &#125;<br><br>    <span class="hljs-comment">// 配置 SecurityFilterChain，即我们熟知的那些过滤器链</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">SecurityFilterChain <span class="hljs-title">securityFilterChain</span><span class="hljs-params">(HttpSecurity httpSecurity)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        httpSecurity<br>                <span class="hljs-comment">// 6. 配置 HttpSession</span><br>                .sessionManagement(session -&gt; &#123;<br>                    session<br>                        .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)<br>                        .maximumSessions(<span class="hljs-number">1</span>)<br>                        .maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>);<br>                &#125;)<br><br>                <span class="hljs-comment">// 7. 添加自定义过滤器</span><br>                .addFilterAt(xxxx)<br>				<br>                <span class="hljs-comment">// 8. 配置 SecurityContextPersistenceFilter 过滤器</span><br>                .securityContext(security -&gt; &#123;<br>                    security.requireExplicitSave(<span class="hljs-keyword">false</span>);<br>                &#125;)<br>				<br>				<span class="hljs-comment">// 9. 配置 RememberMeAuthenticationFilter 过滤器</span><br>				.rememberMe(rememberMe -&gt; &#123;<br>					rememberMe.key(<span class="hljs-string">&quot;yourSecretKey&quot;</span>)<br>				&#125;)<br>				<br>                <span class="hljs-comment">// 10. 配置 CSRF 攻击防护（配置 CsrfFilter 过滤器）</span><br>                .csrf(csrf -&gt; &#123;<br>                    csrf<br>                        .ignoringRequestMatchers(<span class="hljs-string">&quot;/login&quot;</span>) <span class="hljs-comment">// 忽略对这些路径的 CSRF 保护（默认全部保护）</span><br>                        .csrfTokenRepository(csrfTokenRepository()); <span class="hljs-comment">// 使用我们自定义的 Token 存储库</span><br>                &#125;)<br>				<br>                <span class="hljs-comment">// 11. 配置默认表单登录（配置 UsernamePasswordAuthenticationFilter 过滤器）</span><br>                .formLogin(form -&gt; &#123;<br>                    form.disable();<br>                &#125;)<br><br>                <span class="hljs-comment">// 12. 配置默认注销功能（配置 LogoutFilter 过滤器）</span><br>                .logout(logout -&gt; &#123;<br>                    logout.disable();<br>                &#125;)<br>				<br>	            <span class="hljs-comment">// 13. 配置 AnonymousAuthenticationFilter 过滤器</span><br>                .anonymous(anonymous -&gt; anonymous.disable())<br>				<br>                <span class="hljs-comment">// 14. 配置资源级别的访问控制（配置 FilterSecurityInterceptor 过滤器）</span><br>                .authorizeHttpRequests(auth -&gt; &#123;<br>                    auth<br>                        .requestMatchers(<span class="hljs-string">&quot;/public/**&quot;</span>).permitAll()<br>                        .anyRequest().authenticated(); <span class="hljs-comment">// 其他所有路径均需通过认证</span><br>                &#125;)<br><br>                <span class="hljs-comment">// 15. 配置用户 未认证、权限不足 的处理（配置 ExceptionTranslationFilter 过滤器）</span><br>                .exceptionHandling(<span class="hljs-keyword">handler</span> -&gt; &#123;<br>                    <span class="hljs-keyword">handler</span><br>                        <span class="hljs-comment">// 未认证时的响应（处理 AuthenticationException 异常）</span><br>                        .authenticationEntryPoint((request, response, authException) -&gt; &#123;<br>                            response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>                            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);<br>                            response.getWriter().write(<span class="hljs-string">&quot;&#123;\&quot;error\&quot;:\&quot;未认证，请先登录\&quot;&#125;&quot;</span>);<br>                        &#125;)<br>                        <span class="hljs-comment">// 权限不足时的响应（处理 AccessDeniedException 异常）</span><br>                        .accessDeniedHandler((request, response, accessDeniedException) -&gt; &#123;<br>                            response.setContentType(<span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>);<br>                            <span class="hljs-comment">// 先判断是否是 CSRF 相关异常</span><br>                            <span class="hljs-keyword">if</span> (accessDeniedException <span class="hljs-keyword">instanceof</span> MissingCsrfTokenException<br>                                    || accessDeniedException <span class="hljs-keyword">instanceof</span> InvalidCsrfTokenException) &#123;<br>                                response.setStatus(HttpServletResponse.SC_FORBIDDEN);<br>                                response.getWriter().write(<span class="hljs-string">&quot;&#123;\&quot;error\&quot;:\&quot;CSRF Token 校验失败，无法访问此资源\&quot;&#125;&quot;</span>);<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-comment">// 普通权限不足</span><br>                                response.setStatus(HttpServletResponse.SC_FORBIDDEN);<br>                                response.getWriter().write(<span class="hljs-string">&quot;&#123;\&quot;error\&quot;:\&quot;权限不足，无法访问此资源\&quot;&#125;&quot;</span>);<br>                            &#125;<br>                        &#125;);<br>                &#125;);<br><br>        <span class="hljs-function"><span class="hljs-keyword">return</span> httpSecurity.<span class="hljs-title">build</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 构建 SecurityFilterChain 对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-启用方法级别的访问控制"><a href="#3-2-启用方法级别的访问控制" class="headerlink" title="3.2. 启用方法级别的访问控制"></a>3.2. 启用方法级别的访问控制</h3><p>我们先来了解一下资源级别的访问控制，资源级别的访问控制是指：只有具备指定权限或身份的用户，才能访问特定路径下的资源，例如 <code>/api/admin/**</code> ，详见下文：资源级别的访问控制。</p>
<p>而方法级别的访问控制则是指：用户必须具备指定的权限或身份，才能调用某方法，详细步骤如下：</p>
<p><font color="#92d050">1. 配置类上添加 @EnableMethodSecurity 注解</font></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span>  <br><span class="hljs-variable">@EnableMethodSecurity</span>  <span class="hljs-comment">// 启用方法级别的访问控制  </span><br><span class="hljs-variable">@EnableWebSecurity</span>  <br>public class SecurityConfig &#123;  <br>  ......<br>&#125;<br></code></pre></td></tr></table></figure>


<p><font color="#92d050">2. 进行方法级别的访问控制</font><br>需要注意的是，方法级别的访问控制，一般进行在服务层（Service 层）、控制器层（Controller 层）</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Service</span><br>public class UserService &#123;<br>    <span class="hljs-variable">@PreAuthorize</span>(<span class="hljs-string">&quot;hasRole(&#x27;ADMIN&#x27;)&quot;</span>)<br>    public void <span class="hljs-built_in">adminMethod</span>() &#123;<br>        <span class="hljs-comment">// 只有 ROLE_ADMIN 角色可以执行该方法</span><br>    &#125;<br><br>    <span class="hljs-variable">@PreAuthorize</span>(<span class="hljs-string">&quot;hasAuthority(&#x27;user:user:select&#x27;)&quot;</span>) <br>    public void <span class="hljs-built_in">readUser</span>() &#123;<br>        <span class="hljs-comment">// 只有具有 user:user:select 权限的用户可以执行 用户模块的用户表的查询操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>如果你在 <code>Service</code> 层进行了方法级别的访问控制，那么就有可能出现：能够执行前半部分逻辑，但调用 <code>Service</code> 方法时会被拒绝，并抛出 AccessDeniedException</li>
</ol>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/test&quot;</span>)</span>  <br><span class="hljs-keyword">public</span> String test() &#123;  <br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;正在执行只有 test:test:test 权限才能执行的 Service 方法&quot;</span>);  <br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;现在的 Authentication 信息如下：&quot;</span>);  <br>    System.<span class="hljs-keyword">out</span>.println(AuthenticationUtils.getAuthentication());  <br>    String testString = testService.test();  <span class="hljs-comment">// 对 testService 进行方法级别的访问控制</span><br>    <span class="hljs-keyword">return</span> testString;  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-启用-Spring-Security-安全机制"><a href="#3-3-启用-Spring-Security-安全机制" class="headerlink" title="3.3. 启用 Spring Security 安全机制"></a>3.3. 启用 Spring Security 安全机制</h3><p>在配置类中加上 <code>@EnableWebSecurity</code> 后，就会启动 Spring Security</p>
<hr>
<h3 id="3-4-配置-CORS-跨域资源共享"><a href="#3-4-配置-CORS-跨域资源共享" class="headerlink" title="3.4. 配置 CORS 跨域资源共享"></a>3.4. 配置 CORS 跨域资源共享</h3><p>CORS 是指：出于安全考虑，浏览器默认会阻止网页从一个源（如 <code>http://a.com</code>）向另一个源（如 <code>http://b.com/api/data</code>）发起请求，这种“同源策略”能够有效防范诸如 CSRF、XSS 等跨站攻击。但在一些场景下我们确实需要跨源访问，例如当前端和后端分离部署在不同的源时，仍然需要让前端能够访问后端接口。</p>
<p>这时，如果后端的 <code>http://b.com/api/data</code> 启用了 CORS 跨域资源共享机制，那么浏览器就允许网页从 <code>http://a.com</code> 向这个接口发起请求并成功获取数据。</p>
<p>需要注意的是，CORS 跨域资源共享与域名解析得到的 IP 地址无关，而是基于“源”（Origin）来判断。那么什么是“源”呢？“源”由协议（scheme）+ 域名（host）+ 端口号（port）三部分组成，不包括 URL 后面的路径和参数。例如，<code>https://example.com/page</code> 与 <code>https://example.com/another</code> 属于同源，但 <code>http://example.com/page</code> 与 <code>https://example.com/page</code> 就不同源。即便它们甚至解析到相同的 IP，只要协议、域名或端口任一部分不完全相同，就被视为不同源。</p>
<p>需要注意的是，<strong>Spring Security 默认是关闭 CORS 的</strong>，如果需要使用跨域资源共享，必须手动开启并配置相应的跨域策略。</p>
<p>除此之外，CORS 只能解决跨域访问的问题，用户权限不足时依然会被拒绝访问。如果用户没有登录，也就是证明没有开启 “记住我” 功能，那么每个请求都会以匿名身份（匿名 Authentication）访问，对于需要认证的资源，尤其是权限要求较高的资源，这些请求会被 Spring Security 拒绝。换句话说，即使跨域访问成功，没有足够权限也无法访问受保护资源。</p>
<p>通常情况下，我们希望用户先登录，这样就证明启用了 “记住我” 功能，当访问后端的时候，就会携带凭证，自动完成认证逻辑，Spring Security 就能自动识别用户权限。但需要注意的是，如果使用基于 HttpSession 的认证，由于后端服务器可能是集群架构，用户需要在多台服务器上重复登录，带来管理上的复杂性。</p>
<p>因此，结合 CORS 跨域和权限控制，通常推荐使用 JWT（JSON Web Token）认证机制代替 HttpSession，因为 JWT 是无状态的，适合分布式环境，具体实践包括：</p>
<ol>
<li>对公共资源，允许跨域访问，且在 Spring Security 中使用 <code>permitAll</code> 放行，无需登录即可访问；</li>
<li>对私密资源，要求用户先登录，获取 JWT 凭证，前端在跨域请求时携带该 JWT，后端通过 Spring Security 进行权限校验。对于更敏感的操作，还要启用 CSRF 防护，要求前端携带 CSRF Token；</li>
<li>登录认证基于 JWT，避免使用 HttpSession，因为 HttpSession 依赖单台服务器，难以应对集群环境，JWT 则是通用且无状态的认证方案</li>
<li>需要注意的是，如果只是我们自己的项目，仅供内部使用，或者是一些功能较简单的小型项目，后端生成令牌给前端，前端携带令牌访问后端接口，这种情况下我们完全可以自定义过滤器、自行处理令牌校验等逻辑，前后端达成一致即可，问题不大。但如果目标是打造一个对外公开、安全、合规的系统，那就必须遵循 OAuth 的标准化流程和规范。详见笔记：OAuth 协议<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">// 启用 CORS 跨域资源共享，并配置其跨域规则<br>@Bean<br>public CorsConfigurationSource corsConfigurationSource() &#123;<br><br>	CorsConfiguration configuration = new CorsConfiguration();<br>	configuration.setAllowedOrigins(List.of(<span class="hljs-string">&quot;http://frontend.example.com&quot;</span>, <span class="hljs-string">&quot;http://localhost:3000&quot;</span>));<br>	configuration.setAllowedOriginPatterns(List.of(<span class="hljs-string">&quot;http://*.example.com&quot;</span>));<br>	configuration.setAllowedMethods(List.of(<span class="hljs-string">&quot;<span class="hljs-keyword">GET</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">POST</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">PUT</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">DELETE</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">OPTIONS</span>&quot;</span>));<br>	configuration.setAllowedHeaders(List.of(<span class="hljs-string">&quot;*&quot;</span>));<br>	configuration.setAllowCredentials(true);<br><br>	UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();<br>	Map&lt;String, CorsConfiguration&gt; configMap = new HashMap&lt;&gt;();<br>	configMap.put(<span class="hljs-string">&quot;/api/**&quot;</span>, configuration);<br>	configMap.put(<span class="hljs-string">&quot;/admin/**&quot;</span>, configuration);<br>	source.setCorsConfigurations(configMap);<br><br>	return source;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>之前开启 CORS 跨域资源共享，需要写 <code>http.cors</code> 开启 CORS，并且配置 <code>CorsConfigurationSource</code> 跨域规则，现在只需要配置 <code>CorsConfigurationSource</code> 既开启了 CORS，又配置了跨域规则</li>
</ol>
</blockquote>
<p><font color="#92d050">1. configuration.setAllowedOrigins</font><br>用于配置<strong>哪些源可以跨域访问我们</strong>，不支持通配符，需精确指定 “源”（Origin），即需精确指定协议 + 域名 + 端口，注意不能包含后续的 URL 路径部分（因为不符合 Origin 的写法）</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">configuration</span><span class="hljs-selector-class">.setAllowedOrigins</span>(List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;http://frontend.example.com:8888&quot;</span>, <span class="hljs-string">&quot;http://frontend.example.com&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>));<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>未指定端口，将使用协议的默认端口（http 默认是 80 端口，https 默认是 443 端口）</li>
<li>不能与 <code>configuration.setAllowedOriginPatterns</code> 同时使用</li>
</ol>
</blockquote>
<p><font color="#92d050">2. configuration.setAllowedOriginPatterns</font><br>与 <code>configuration.setAllowedOrigins</code> 类似，但能支持通配符（<code>?</code>、<code>*</code>、<code>**</code>）</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">configuration.setAllowedOriginPatterns(List.of(<span class="hljs-string">&quot;http://*.example.com&quot;</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>由于是源匹配，不能包含后续的 URL 路径部分，所以 <code>**</code> 是不适用于这种情况的</li>
<li>补充一下三种通配符常见用法：</li>
</ol>
</blockquote>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 1. ?，匹配单个字符</span><br><span class="hljs-selector-tag">configuration</span><span class="hljs-selector-class">.setAllowedOriginPatterns</span>(List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;http://a?.example.com&quot;</span>));<br><br><br><span class="hljs-comment">// 2. *，匹配单个路径段的多个字符</span><br><span class="hljs-selector-tag">configuration</span><span class="hljs-selector-class">.setAllowedOriginPatterns</span>(List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;http://*.example.com&quot;</span>));<br><br><br><span class="hljs-comment">// 3. **，匹配任意层级的路径段（不适用于 Origin 匹配，适用于 URL 匹配）</span><br><span class="hljs-selector-tag">source</span><span class="hljs-selector-class">.registerCorsConfiguration</span>(<span class="hljs-string">&quot;/api/**&quot;</span>, config);<br></code></pre></td></tr></table></figure>


<p><font color="#92d050">3. configuration.setAllowedMethods</font><br>指定允许哪些 HTTP 方法能够执行跨域请求，例如：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">configuration.setAllowedMethods(List.of(<span class="hljs-string">&quot;<span class="hljs-keyword">GET</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">POST</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">PUT</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">DELETE</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-keyword">OPTIONS</span>&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>));<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>若要允许所有 HTTP 方法都能够执行跨域请求，可以写成：</li>
</ol>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">configuration.setAllowedMethods(List.of(<span class="hljs-string">&quot;*&quot;</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>


<p><font color="#92d050">4. configuration.setAllowedHeaders</font><br>配置前端在跨域请求中<strong>允许携带的请求头</strong>，如果前端发送的请求头未被我们明确允许，浏览器会直接拦截请求，根本不会发送到服务器，例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">configuration</span><span class="hljs-selector-class">.setAllowedHeaders</span>(List.<span class="hljs-built_in">of</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>));<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>若要允许前端携带任意请求头，可以写成：</li>
</ol>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">configuration.setAllowedHeaders(List.of(<span class="hljs-string">&quot;*&quot;</span>))<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>


<p><font color="#92d050">5. configuration.setAllowCredentials  </font><br>在讲解这个之前，我们先补充一个前置知识：当我们是同源访问时，前端访问后端，一般是使用 AJAX 进行请求的，然后浏览器会自动携带 Cookie 发送到后端，这点大家都很熟悉。但是在跨域访问时，出于安全考虑，浏览器默认不会携带 Cookie。如果想让浏览器携带 Cookie，前端必须在 AJAX 请求中添加 <code>credentials: &#39;include&#39;</code>，这样 Cookie 才会被发送。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl">// 前端请求示例：<br>fetch(<span class="hljs-string">&#x27;http://api.example.com/user/info&#x27;</span>, &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">method</span>: &#x27;<span class="hljs-title">GET</span>&#x27;,</span><br><span class="hljs-function">  <span class="hljs-title">headers</span>: </span>&#123;<br>    <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer xxxxxx&#x27;</span><br>  &#125;,<br>  credentials: <span class="hljs-string">&#x27;include&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>但并不是说你前端愿意携带 Cookie，我后端就理所当然地愿意接收。因为后端并不知道你发送过来的 Cookie 是出于正常用途，还是存在安全隐患。也就是说，我们的 <code>configuration.setAllowCredentials</code> 默认值是 <code>false</code>，即使前端执意携带 Cookie 发起请求，接口本身执行并正常返回了响应，浏览器也会因为安全策略自动屏蔽返回结果，导致前端无法正常获取数据。</p>
<p>如果将其设置为 <code>true</code>，意味着前后端达成共识，允许使用 Cookie，这样跨域请求才能正常携带 Cookie 并获得返回结果：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">configuration</span>.setAllowCredentials(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>当设置 <code>configuration.setAllowCredentials(true);</code> 时，就不能再允许所有来源访问，即不能使用 <code>configuration.setAllowedOrigins(List.of(&quot;*&quot;));</code>，需要明确指定允许的域名（Spring Security 为了我们的安全真是煞费苦心了）</li>
<li>如果不涉及到 Cookie，其实不用去做这样一系列操作</li>
<li>跨域请求不携带 Cookie，指的是通过 AJAX 发起的请求；但如果是通过 HTML 元素导航发起的请求，比如 <code>&lt;img src=&quot;https://bank.com/transfer?to=attacker&amp;amount=10000&quot; /&gt;</code>，无论是否跨域，浏览器都会自动携带对应 Cookie。这也是为什么我们需要 CSRF 防护的原因。</li>
</ol>
</blockquote>
<p><font color="#92d050">6. source.setCorsConfigurations</font><br>指定我们配置的跨域规则作用于那些路径</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">configMap.<span class="hljs-keyword">put</span>(<span class="hljs-string">&quot;/api/**&quot;</span>, configuration);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>全部路径我们可以写成：</li>
</ol>
</blockquote>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">configMap.<span class="hljs-keyword">put</span>(<span class="hljs-string">&quot;/**&quot;</span>, configuration);<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-5-配置-AuthenticationManager"><a href="#3-5-配置-AuthenticationManager" class="headerlink" title="3.5. 配置 AuthenticationManager"></a>3.5. 配置 AuthenticationManager</h3><p>在 <code>WebSecurityConfigurerAdapter</code> 时代，<code>AuthenticationManager</code> 是由 Spring 官方默认注册为 Bean 的，因此我们可以直接注入使用。</p>
<p>但从 Spring Boot 3 开始，Spring 的设计理念发生了变化：“最少暴露、最少干预”，也就是说框架不再自动为你暴露未显式声明的组件，目的是减少默认暴露导致的 Bean 冲突或安全隐患。</p>
<p>也就是说，Spring 将配置的主动权交还给开发者，所有需要使用的组件开发者都必须通过 <code>@Bean</code> 显式声明，而不是官方为你偷偷注入。即使 Spring Security 已经内部实现了默认的 <code>AuthenticationManager</code>，但也不会自动将其注册为 Bean。例如它在源码中是这样定义的：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthenticationConfiguration</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> AuthenticationManager getAuthenticationManagerBean() &#123;  <br>        <span class="hljs-keyword">return</span> (AuthenticationManager)<span class="hljs-keyword">this</span>.lazyBean(AuthenticationManager.<span class="hljs-keyword">class</span>);  <br>    &#125;  <br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果开发者想使用 <code>AuthenticationManager</code>，就需要自己显式地从官方配置中获取其默认实现，或者直接自定义一个。通常我们使用的 <code>AuthenticationManager</code> 实际上就是官方默认实现的那个，除非你有特殊需求需要进行自定义配置，因此我们可以这样手动声明：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Bean</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-function">AuthenticationManager <span class="hljs-title">authenticationManager</span><span class="hljs-params">(AuthenticationConfiguration authenticationConfiguration)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-keyword">return</span> authenticationConfiguration.<span class="hljs-title">getAuthenticationManager</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 从 Spring Security 配置中获取其默认的 AuthenticationManager 实例</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>如果我们是使用 <code>AuthenticationManager</code> 进行认证，它会自动将用户发送来的用户名和密码，与我们的 <code>CustomerUserDetailsImpl</code> 中返回的用户名和密码进行比对，这是我们已知的逻辑。那你可能会有疑问：它在比对前，肯定需要先用密码加密器对用户发送来的明文密码进行加密，然后再比对吧？可我并没有做任何相关配置，<code>AuthenticationManager</code> 怎么知道该使用哪个加密器？</li>
<li>其实，只要你注册了一个类型为 <code>PasswordEncoder</code> 的 接口 Bean，这个 接口 Bean 有一个具体实现，<code>AuthenticationManager</code> 就会知道使用这个 <code>PasswordEncoder</code> Bean 与其具体实现，对密码进行加密，<strong>无需我们手动配置</strong>。</li>
<li>同样的，只要你注册了一个类型为 <code>UserDetailsService</code> 的 Bean（接口 Bean），这个 接口 Bean 有一个具体的实现，<code>AuthenticationManager</code> 就会知道使用这个 <code>UserDetailsService</code> Bean 与其具体实现，去获取 <code>CustomerUserDetailsImpl</code> <strong>无需我们手动配置</strong>。</li>
<li>上述，只限于接口 Bean 只有一个具体实现，如果有多个具体实现，那就要我们进行配置了，因为 Spring Security 虽然知道用这个 Bean，但是并不知道使用哪一个具体实现</li>
</ol>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/**<br><span class="hljs-bullet"> *</span> ============================================<br><span class="hljs-bullet"> *</span> Spring IoC 声明 Bean 的常用方式 1<br><span class="hljs-bullet"> *</span> --------------------------------------------<br><span class="hljs-bullet"> *</span> 概念：<br><span class="hljs-bullet"> *</span> - 同时注册了 UserDetailsService 接口类型的 Bean 和 CustomerUserDetailsImplService 实现类类型的 Bean<br><span class="hljs-bullet"> *</span> - CustomerUserDetailsImplService 是该接口的一个具体实现类，IoC 容器中可能存在多个这样的实现类 Bean<br><span class="hljs-bullet"> *</span> - 我们既可以注入 CustomerUserDetailsImplService 类 Bean，也可以注入 UserDetailsService 接口 Bean<br><span class="hljs-bullet"> *</span> - 如果注入的是 UserDetailsService，且只有一个实现类，那么调用接口方法时，实际就是调用该实现类的方法<br><span class="hljs-bullet"> *</span> - 如果存在多个实现类，则需要通过配置明确指定使用哪个实现类<br><span class="hljs-bullet"> *</span> - 简而言之，此方式支持一个接口 Bean 有多个实现类 Bean，切换实现时只需调整配置，指定使用哪一个实现即可<br><span class="hljs-bullet"> *</span> ============================================<br> <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">@Service</span><br><span class="hljs-emphasis">public class CustomerUserDetailsImplService implements UserDetailsService &#123;</span><br><span class="hljs-emphasis">	......</span><br><span class="hljs-emphasis">&#125;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">/*</span>*<br><span class="hljs-bullet"> *</span> ============================================<br><span class="hljs-bullet"> *</span> Spring IoC 声明 Bean 的常用方式 2<br><span class="hljs-bullet"> *</span> --------------------------------------------<br><span class="hljs-bullet"> *</span> 概念：<br><span class="hljs-bullet"> *</span> - 仅注册了 UserDetailsService 类型的 Bean，返回的 CustomerUserDetailsImplService 实例是其具体实现类<br><span class="hljs-bullet"> *</span> - 此方式下，一个接口 Bean 只能绑定一个实现类，若要更换实现，需在此方法中直接修改返回的实例。<br><span class="hljs-bullet"> *</span> ============================================<br> <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">@Bean</span><br><span class="hljs-emphasis">public UserDetailsService userDetailsService() &#123;</span><br><span class="hljs-emphasis">    return new CustomerUserDetailsImplService();</span><br><span class="hljs-emphasis">&#125;</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-6-配置密码加密器"><a href="#3-6-配置密码加密器" class="headerlink" title="3.6. 配置密码加密器"></a>3.6. 配置密码加密器</h3><p>在实际应用中，用户密码绝不能以明文方式存储，因为这会带来极大的安全风险。为确保安全性，我们必须在存储前对密码进行加密处理。基于此，我们面临两大问题：</p>
<ol>
<li>如何实现密码加密，即如何将明文密码转换为<strong>不可逆</strong>的密文，从而保护用户密码安全</li>
<li>如何校验密码，即用户提交的明文密码如何与存储的密文密码进行对比，从而验证密码的正确性</li>
</ol>
<p><code>PasswordEncoder</code> 是 Spring Security 提供的一个接口，同时 Spring Security 也提供了该接口的很多实现类（未声明未 Bean），能够解决上述两大问题</p>
<p>配置密码加密器，就是将 <code>PasswordEncoder</code> 声明为一个 Bean，并指定返回一个合适的的实现类。这样当我们注入这个 Bean，并调用其接口方法时，实际执行的就是这个实现类的逻辑，这正体现了 Spring IoC 的核心理念：<strong>面向接口编程，运行时注入实现</strong>。不理解这一点，那确实建议回去复习一下 IoC，我们密码加密器的配置，以及如何使用密码加密器解决上述两大问题，常按照这种流程：<br><font color="#92d050">1. 配置密码加密器</font></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/**<br><span class="hljs-bullet"> *</span> ============================================<br><span class="hljs-bullet"> *</span> 配置密码加密器<br><span class="hljs-bullet"> *</span> --------------------------------------------<br><span class="hljs-bullet"> *</span> Spring Security 提供的常见实现类：<br><span class="hljs-bullet"> *</span> - BCryptPasswordEncoder<br><span class="hljs-bullet"> *</span>      - 基于 BCrypt 算法的密码加密工具，不能解密，只能对比，是一种提供较高安全的密码加密方式，能够有效防止暴力破解，适用于大多数应用<br><span class="hljs-bullet"> *</span>      - return new BCryptPasswordEncoder();<br><span class="hljs-bullet"> *</span> - NoOpPasswordEncoder<br><span class="hljs-bullet"> *</span>      - 不对密码进行加密，直接返回原始密码，通常用于开发、测试环境，不建议在生产环境中使用。<br><span class="hljs-bullet"> *</span>      - return NoOpPasswordEncoder.getInstance();<br><span class="hljs-bullet"> *</span> - Pbkdf2PasswordEncoder<br><span class="hljs-bullet"> *</span>      - 基于 PBKDF2 算法的密码加密工具<br><span class="hljs-bullet"> *</span> - SCryptPasswordEncoder<br><span class="hljs-bullet"> *</span>      - 基于 scrypt 算法的密码加密工具<br><span class="hljs-bullet"> *</span> ============================================<br> <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">@Bean</span><br><span class="hljs-emphasis">public PasswordEncoder passwordEncoder() &#123;</span><br><span class="hljs-emphasis">	return NoOpPasswordEncoder.getInstance(); // 返回合适的实现类</span><br><span class="hljs-emphasis">&#125;</span><br></code></pre></td></tr></table></figure>


<p><font color="#92d050">2. 使用 PasswordEncoder 实现密码加密</font></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Controller</span>  <br><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/security&quot;</span>)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PasswordController</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PasswordEncoder passwordEncoder;  <br>  <br>    <span class="hljs-meta">@Autowired</span>  <br>    <span class="hljs-keyword">public</span> PasswordController(PasswordEncoder passwordEncoder) &#123;  <br>        <span class="hljs-keyword">this</span>.passwordEncoder = passwordEncoder;  <br>    &#125;  <br>      <br>    <span class="hljs-comment">// 通过方法处理密码加密  </span><br>    <span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/encode-password&quot;</span>)</span>  <br>    <span class="hljs-meta">@ResponseBody</span>  <br>    <span class="hljs-keyword">public</span> String encodePassword() &#123;  <br>        String password = <span class="hljs-string">&quot;myPasswordxxxxxxx&quot;</span>;  <br>        <span class="hljs-comment">// 在方法内调用 passwordEncoder 进行密码加密  </span><br>        String encodedPassword = passwordEncoder.encode(password);  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Encoded Password: &quot;</span> + encodedPassword;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>


<p><font color="#92d050">3. 校验密码匹配</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/security&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PasswordController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PasswordEncoder passwordEncoder;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PasswordController</span><span class="hljs-params">(PasswordEncoder passwordEncoder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.passwordEncoder = passwordEncoder;<br>    &#125;<br><br>    <span class="hljs-comment">// 通过方法验证密码</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/verify-password&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">verifyPassword</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rawPassword</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;myPasswordxxxxxxx&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">encodedPassword</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxx&quot;</span>;  <span class="hljs-comment">// 模拟数据库中的加密密码</span><br><br>        <span class="hljs-comment">// 使用 matches 方法验证密码是否匹配</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">matches</span> <span class="hljs-operator">=</span> passwordEncoder.matches(rawPassword, encodedPassword);<br>        <br>        <span class="hljs-keyword">return</span> matches ? <span class="hljs-string">&quot;Password is valid&quot;</span> : <span class="hljs-string">&quot;Invalid password&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>使用 <code>matches</code> 方法时，实际上是<strong>先对 rawPassword 进行加密</strong>，然后再与数据库中的加密密码进行匹配）</li>
<li>如果我们是使用 <code>AuthenticationManager</code> 进行认证，它会自动将用户发送来的用户名和密码，与我们的 <code>CustomerUserDetailsImpl</code> 中返回的用户名和密码进行比对，这是我们已知的逻辑。那你可能会有疑问：它在比对前，肯定需要先用密码加密器对用户发送来的明文密码进行加密，然后再比对吧？可我并没有做任何相关配置，<code>AuthenticationManager</code> 怎么知道该使用哪个加密器？</li>
<li>其实，只要你注册了一个类型为 <code>PasswordEncoder</code> 的 接口 Bean，这个 接口 Bean 有一个具体实现，<code>AuthenticationManager</code> 就会知道使用这个 <code>PasswordEncoder</code> Bean 与其具体实现，对密码进行加密，<strong>无需我们手动配置</strong>。</li>
<li>同样的，只要你注册了一个类型为 <code>UserDetailsService</code> 的 Bean（接口 Bean），这个 接口 Bean 有一个具体的实现，<code>AuthenticationManager</code> 就会知道使用这个 <code>UserDetailsService</code> Bean 与其具体实现，去获取 <code>CustomerUserDetailsImpl</code> <strong>无需我们手动配置</strong>。</li>
<li>上述，只限于接口 Bean 只有一个具体实现，如果有多个具体实现，那就要我们进行配置了，因为 Spring Security 虽然知道用这个 Bean，但是并不知道使用哪一个具体实现</li>
</ol>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs markdown">/**<br><span class="hljs-bullet"> *</span> ============================================<br><span class="hljs-bullet"> *</span> Spring IoC 声明 Bean 的常用方式 1<br><span class="hljs-bullet"> *</span> --------------------------------------------<br><span class="hljs-bullet"> *</span> 概念：<br><span class="hljs-bullet"> *</span> - 同时注册了 UserDetailsService 接口类型的 Bean 和 CustomerUserDetailsImplService 实现类类型的 Bean<br><span class="hljs-bullet"> *</span> - CustomerUserDetailsImplService 是该接口的一个具体实现类，IoC 容器中可能存在多个这样的实现类 Bean<br><span class="hljs-bullet"> *</span> - 我们既可以注入 CustomerUserDetailsImplService 类 Bean，也可以注入 UserDetailsService 接口 Bean<br><span class="hljs-bullet"> *</span> - 如果注入的是 UserDetailsService，且只有一个实现类，那么调用接口方法时，实际就是调用该实现类的方法<br><span class="hljs-bullet"> *</span> - 如果存在多个实现类，则需要通过配置明确指定使用哪个实现类<br><span class="hljs-bullet"> *</span> - 简而言之，此方式支持一个接口 Bean 有多个实现类 Bean，切换实现时只需调整配置，指定使用哪一个实现即可<br><span class="hljs-bullet"> *</span> ============================================<br> <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">@Service</span><br><span class="hljs-emphasis">public class CustomerUserDetailsImplService implements UserDetailsService &#123;</span><br><span class="hljs-emphasis">	......</span><br><span class="hljs-emphasis">&#125;</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">/*</span>*<br><span class="hljs-bullet"> *</span> ============================================<br><span class="hljs-bullet"> *</span> Spring IoC 声明 Bean 的常用方式 2<br><span class="hljs-bullet"> *</span> --------------------------------------------<br><span class="hljs-bullet"> *</span> 概念：<br><span class="hljs-bullet"> *</span> - 仅注册了 UserDetailsService 类型的 Bean，返回的 CustomerUserDetailsImplService 实例是其具体实现类<br><span class="hljs-bullet"> *</span> - 此方式下，一个接口 Bean 只能绑定一个实现类，若要更换实现，需在此方法中直接修改返回的实例。<br><span class="hljs-bullet"> *</span> ============================================<br> <span class="hljs-emphasis">*/</span><br><span class="hljs-emphasis">@Bean</span><br><span class="hljs-emphasis">public UserDetailsService userDetailsService() &#123;</span><br><span class="hljs-emphasis">    return new CustomerUserDetailsImplService();</span><br><span class="hljs-emphasis">&#125;</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-7-添加自定义过滤器"><a href="#3-7-添加自定义过滤器" class="headerlink" title="3.7. 添加自定义过滤器"></a>3.7. 添加自定义过滤器</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 1. 直接添加过滤器，添加的过滤器必须是 Spring Security 提供的过滤器或其子类的实例</span><br>http.<span class="hljs-built_in">addFilter</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">CustomFilter</span>());<br><br><br><span class="hljs-comment">// 2. 在指定的过滤器位置添加过滤器，新添加的过滤器会替换指定位置的原有过滤器</span><br>http.<span class="hljs-built_in">addFilterAt</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">CustomFilter</span>(),UsernamePasswordAuthenticationFilter.<span class="hljs-keyword">class</span>);<br><br><br><span class="hljs-comment">// 3. 在指定过滤器之前添加过滤器，自定义过滤器会在指定过滤器之前执行。</span><br>http.<span class="hljs-built_in">addFilterBefore</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">CustomFilter</span>(),UsernamePasswordAuthenticationFilter.<span class="hljs-keyword">class</span>);<br><br><br><span class="hljs-comment">// 4. 在指定过滤器之后添加过滤器，自定义过滤器会在指定过滤器之后执行。</span><br>http.<span class="hljs-built_in">addFilterAfter</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">CustomFilter</span>(),UsernamePasswordAuthenticationFilter.<span class="hljs-keyword">class</span>);<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-8-配置-HttpSession"><a href="#3-8-配置-HttpSession" class="headerlink" title="3.8. 配置 HttpSession"></a>3.8. 配置 HttpSession</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">http</span><span class="hljs-selector-class">.sessionManagement</span>(session -&gt; session  <br>    .<span class="hljs-built_in">sessionCreationPolicy</span>(SessionCreationPolicy.IF_REQUIRED)  <br>    .<span class="hljs-built_in">maximumSessions</span>(<span class="hljs-number">1</span>)<br>    .<span class="hljs-built_in">maxSessionsPreventsLogin</span>(true)<br>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>Spring Security 本身不负责设置 <code>HttpSession</code> 的会话超时时间。会话超时时间由 Servlet 容器或 Spring Boot 配置决定。</li>
<li><code>HttpSession</code> 存储在服务器端，别误以为存储在用户端了</li>
<li>如果不希望使用会话，可以配置为：</li>
</ol>
</blockquote>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">http<span class="hljs-selector-class">.sessionManagement</span>()<span class="hljs-selector-class">.sessionCreationPolicy</span>(SessionCreationPolicy.STATELESS);<br></code></pre></td></tr></table></figure>

<p><font color="#92d050">1. session.sessionCreationPolicy()</font><br>用于配置会话的创建策略，常见策略有：</p>
<ol>
<li>SessionCreationPolicy.ALWAYS：<ol>
<li>始终创建会话。每个请求都会新建一个 HttpSession，覆盖之前的会话，并返回新的 JSESSIONID Cookie。</li>
</ol>
</li>
<li>SessionCreationPolicy.IF_REQUIRED（默认）：<ol>
<li>按需创建会话。当需要使用 HttpSession 时，Spring Security 会自动创建会话，并返回对应的 JSESSIONID Cookie。</li>
</ol>
</li>
<li>SessionCreationPolicy.STATELESS：<ol>
<li>不使用会话（每次请求都不会创建或使用现有的 Session）</li>
<li>适用于无状态应用场景（如 JWT、OAuth2）<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">.sessionManagement(<span class="hljs-keyword">session</span> -&gt; &#123;  <br>    <span class="hljs-keyword">session</span>  <br>        .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED);<br>&#125;)<br></code></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p><font color="#92d050">2. session.maximumSessions()</font><br>并发会话控制，即限制每个用户在同一时间内的会话数量，也即用户可在多少台设备上同时登录（默认情况下，不限制）</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">session</span>.maximumSessions(<span class="hljs-number">1</span>)<br>.sessionManagement(<span class="hljs-keyword">session</span> -&gt; &#123;  <br>    <span class="hljs-keyword">session</span>  <br>        .maximumSessions(<span class="hljs-number">1</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>


<p><font color="#92d050">3. maxSessionsPreventsLogin()</font><br>是否阻止新会话登录</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs abnf">/**<br> * <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br> * 是否阻止新会话登录<br> * --------------------------------------------<br> * 选项：<br> * - true<br> *      - 达到最大会话数后阻止新会话登录，不允许替换旧会话。<br> * - false<br> *      - 允许新会话登录并替换旧会话<br> *      - 此时旧会话将被注销，旧的 JSESSIONID 失效。<br> *      - 我们通知用户被挤下线，并重定向到登录页面要求重新登录。<br> * <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br> */<br>.sessionManagement(session -&gt; &#123;  <br>    session  <br>        .maxSessionsPreventsLogin(true)<span class="hljs-comment">;  </span><br>&#125;)<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-9-配置-SecurityContextPersistenceFilter-过滤器"><a href="#3-9-配置-SecurityContextPersistenceFilter-过滤器" class="headerlink" title="3.9. 配置 SecurityContextPersistenceFilter 过滤器"></a>3.9. 配置 SecurityContextPersistenceFilter 过滤器</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 禁用 SecurityContextPersistenceFilter 过滤器（强烈不建议禁用）</span><br>http<span class="hljs-selector-class">.securityContext</span>(securityContext -&gt; securityContext<span class="hljs-selector-class">.disable</span>())  <br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li><code>SecurityContextPersistenceFilter</code> 过滤器会在当前线程中的 <code>SecurityContext</code> 发生变化时，将其自动保存到 <code>HttpSession</code> 中。但需要注意的是，这一功能默认并未开启，需要我们<strong>显式手动开启</strong>：</li>
</ol>
</blockquote>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">http</span>.securityContext(securityContext -&gt;</span> securityContext.requireExplicitSave(<span class="hljs-literal">false</span>));<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-10-配置-RememberMeAuthenticationFilter-过滤器"><a href="#3-10-配置-RememberMeAuthenticationFilter-过滤器" class="headerlink" title="3.10. 配置 RememberMeAuthenticationFilter 过滤器"></a>3.10. 配置 RememberMeAuthenticationFilter 过滤器</h3><h3 id="3-11-配置-CSRF-攻击防护（配置-CsrfFilter-过滤器）"><a href="#3-11-配置-CSRF-攻击防护（配置-CsrfFilter-过滤器）" class="headerlink" title="3.11. 配置 CSRF 攻击防护（配置 CsrfFilter 过滤器）"></a>3.11. 配置 CSRF 攻击防护（配置 CsrfFilter 过滤器）</h3><p>Spring Security 默认启用跨站请求伪造（CSRF）防护机制，基于 <strong>CSRF Token</strong> 实现安全校验。其工作原理如下：</p>
<ol>
<li>用户发出请求时，CsrfFilter 过滤器会尝试从我们配置的 CSRF Token 存储位置（配置的 <code>HttpSessionCsrfTokenRepository</code>）中加载 CSRF Token，且所有请求都会经过这一尝试。若成功加载，Token 会被放入 <code>HttpServletRequest</code> 中；如果未加载到，则会创建一个新的 CSRF Token，并同样放入请求中。</li>
<li>当用户进行登录时，我们可以从 <code>HttpServletRequest</code> 中拿到 CSRF Token，并返回给前端</li>
<li>前端需妥善保存该 Token（不得存入 Cookie），在执行修改服务器状态的敏感操作（如 POST、PUT、DELETE、PATCH 等）时，前端必须将该 Token 携带，通常以请求头（默认名称：<code>X-CSRF-TOKEN</code>）或请求参数（名称：<code>_csrf</code>）的方式携带。</li>
<li>对于启用 CSRF 防护的路径（默认全部启用），当执行修改服务器状态的敏感操作（如 POST、PUT、DELETE、PATCH 等）时，过滤器会检查前端是否在指定的位置（配置的 <code>.setHeaderName(&quot;X-CSRF-TOKEN&quot;)</code> 等位置）携带了 Token。若未携带，则抛出 <code>MissingCsrfTokenException</code>；若携带，则会将前端 Token 与 <code>HttpServletRequest</code> 中的 Token 进行比对，匹配则继续执行，不匹配则抛出 <code>InvalidCsrfTokenException</code>。</li>
<li>即使攻击者能利用用户的 Cookie 或者 JWT 发起请求，由于敏感操作必须携带合法的 CSRF Token，而攻击者无法获取或伪造该 Token，因而能有效防止 CSRF 攻击。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> CsrfTokenRepository <span class="hljs-title function_">csrfTokenRepository</span><span class="hljs-params">()</span> &#123;<br><br>	<span class="hljs-type">HttpSessionCsrfTokenRepository</span> <span class="hljs-variable">repository</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpSessionCsrfTokenRepository</span>(); <span class="hljs-comment">// CSRF Token 生成与加载的位置，这里是生成并保存在 HttpSession 中，并从 HttpSession 中加载</span><br><br>	repository.setHeaderName(<span class="hljs-string">&quot;X-CSRF-TOKEN&quot;</span>); <span class="hljs-comment">// 前端可在 X-CSRF-TOKEN 请求头中携带 CSRF Token</span><br>	repository.setParameterName(<span class="hljs-string">&quot;_csrfToken&quot;</span>); <span class="hljs-comment">// 前端可在 _csrfToken 请求体中携带 CSRF Token</span><br>	<span class="hljs-keyword">return</span> repository;<br>&#125;<br><br>http.csrf(csrf -&gt; &#123;  <br>    csrf  <br>        .ignoringRequestMatchers(<span class="hljs-string">&quot;/login&quot;</span>) <span class="hljs-comment">// 忽略对这些路径的 CSRF 保护（默认全部保护）  </span><br>        .csrfTokenRepository(csrfTokenRepository()); <span class="hljs-comment">// 使用我们自定义的 Token 存储库  </span><br>&#125;);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>同样能支持通配符（<code>?</code>、<code>*</code>、<code>**</code>）</li>
<li>CSRF 攻击的本质是：利用浏览器自动携带 Cookie 的特性，攻击者诱导用户在已登录的网站执行非本意的操作</li>
<li>如果我们基于 JWT，通常可以直接禁用 CSRF 防护，因为浏览器是不会自动发送 JWT，必须前端主动将 Token 放到请求头中，因此攻击者无法通过简单的跨站请求强制浏览器带上有效的 JWT</li>
<li>开发过程中，可以先禁用 CSRF 防护，到最后再根据 API 隐私进行 CSRF 防护</li>
<li>如果想要禁用 CSRF 防护，可以配置为：</li>
</ol>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">http.csrf(csrf -&gt; csrf.<span class="hljs-built_in">disable</span>());<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-12-配置默认表单登录（配置-UsernamePasswordAuthenticationFilter-过滤器）"><a href="#3-12-配置默认表单登录（配置-UsernamePasswordAuthenticationFilter-过滤器）" class="headerlink" title="3.12. 配置默认表单登录（配置 UsernamePasswordAuthenticationFilter 过滤器）"></a>3.12. 配置默认表单登录（配置 UsernamePasswordAuthenticationFilter 过滤器）</h3><h3 id="3-13-配置默认注销功能（配置-LogoutFilter-过滤器）"><a href="#3-13-配置默认注销功能（配置-LogoutFilter-过滤器）" class="headerlink" title="3.13. 配置默认注销功能（配置 LogoutFilter 过滤器）"></a>3.13. 配置默认注销功能（配置 LogoutFilter 过滤器）</h3><h3 id="3-14-配置-AnonymousAuthenticationFilter-过滤器"><a href="#3-14-配置-AnonymousAuthenticationFilter-过滤器" class="headerlink" title="3.14. 配置 AnonymousAuthenticationFilter 过滤器"></a>3.14. 配置 AnonymousAuthenticationFilter 过滤器</h3><p>AnonymousAuthenticationFilter 默认启用，我们可以给他禁用：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">.anonymous(anonymous -&gt; anonymous.<span class="hljs-built_in">disable</span>())<br></code></pre></td></tr></table></figure>




<h3 id="3-15-配置资源级别的访问控制（配置-FilterSecurityInterceptor-过滤器）"><a href="#3-15-配置资源级别的访问控制（配置-FilterSecurityInterceptor-过滤器）" class="headerlink" title="3.15. 配置资源级别的访问控制（配置 FilterSecurityInterceptor 过滤器）"></a>3.15. 配置资源级别的访问控制（配置 FilterSecurityInterceptor 过滤器）</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.authorizeHttpRequests</span><span class="hljs-params">(auth -&gt; &#123;</span><br><span class="hljs-params">	auth</span><br><span class="hljs-params">		.requestMatchers(&quot;/public/**&quot;)</span><span class="hljs-string">.permitAll</span><span class="hljs-params">()</span><br>		<span class="hljs-string">.anyRequest</span><span class="hljs-params">()</span><span class="hljs-string">.authenticated</span><span class="hljs-params">()</span>; <span class="hljs-string">//</span> 其他所有路径均需通过认证<br>&#125;)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>同样能支持通配符（<code>?</code>、<code>*</code>、<code>**</code>）</li>
<li>如需放行所有请求，可配置为：</li>
</ol>
</blockquote>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 允许匿名 Authentication 身份即可访问所有请求（非 Authentication 用户仍然不能访问）</span><br><span class="hljs-selector-tag">http</span><span class="hljs-selector-class">.authorizeHttpRequests</span>(auth -&gt; auth.<span class="hljs-built_in">anyRequest</span>().<span class="hljs-built_in">permitAll</span>());<br></code></pre></td></tr></table></figure>

<p><font color="#92d050">1. auth.requestMatchers()</font><br>设置<strong>指定资源路径</strong>的访问控制规则，例如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs abnf">/**<br> * <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br> * 指定资源路径的访问控制规则<br> * --------------------------------------------<br> * 常用规则：<br> * - permitAll()<br> *      - 允许所有用户访问该资源（说是所有用户，其实你至少要有匿名的 Authentication）<br> * - denyAll()<br> *      - 禁止所有用户访问该资源。<br> * - hasRole()<br> *      - 要求用户必须具备指定角色才能访问<br> *      - 需要注意的是，该方法会自动在角色名前添加 <span class="hljs-string">&quot;ROLE_&quot;</span> 前缀，即：hasRole(<span class="hljs-string">&quot;ADMIN&quot;</span>) 代表 ROLE_ADMIN<br> * - hasAuthority()<br> *      - 要求用户必须具备指定权限才能访问，我们用这个就好<br> *      - 需要注意的是，不会自动添加前缀，提供完整权限名称即可<br> * - authenticated()<br> *      - 要求用户已通过身份验证（即非匿名 Authenticated 而是认证 Authenticated）后才能访问。<br> * - access()<br> *      - 支持使用 SpEL 表达式，实现更复杂的访问控制逻辑。<br> *      - 例如：access(<span class="hljs-string">&quot;hasRole(&#x27;ADMIN&#x27;) and hasIpAddress(&#x27;192.168.1.0/24&#x27;)&quot;</span>) ，是说此路径仅允许拥有 ADMIN 角色且 IP 地址位于 <span class="hljs-number">192.168</span>.<span class="hljs-number">1.0</span>/<span class="hljs-number">24</span> 网段的用户访问<br> * <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br> */<br>.authorizeHttpRequests(auth -&gt; &#123;<br>	auth<br>		.requestMatchers(<span class="hljs-string">&quot;/public/**&quot;</span>).permitAll()<br>		.anyRequest().authenticated()<span class="hljs-comment">; // 其他所有路径均需通过认证</span><br>&#125;)<br></code></pre></td></tr></table></figure>


<p><font color="#92d050">2. auth.anyRequest()</font><br>除已配置的资源路径外，其余所有资源路径的访问控制规则</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">.authorizeHttpRequests</span><span class="hljs-params">(auth -&gt; &#123;</span><br><span class="hljs-params">	auth</span><br><span class="hljs-params">		.requestMatchers(&quot;/public/**&quot;)</span><span class="hljs-string">.permitAll</span><span class="hljs-params">()</span><br>		<span class="hljs-string">.anyRequest</span><span class="hljs-params">()</span><span class="hljs-string">.authenticated</span><span class="hljs-params">()</span>; <span class="hljs-string">//</span> 其他所有路径均需通过认证<br>&#125;)<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-16-配置用户-未认证、权限不足-的处理（配置-ExceptionTranslationFilter-过滤器）"><a href="#3-16-配置用户-未认证、权限不足-的处理（配置-ExceptionTranslationFilter-过滤器）" class="headerlink" title="3.16. 配置用户 未认证、权限不足 的处理（配置 ExceptionTranslationFilter 过滤器）"></a>3.16. 配置用户 未认证、权限不足 的处理（配置 ExceptionTranslationFilter 过滤器）</h3><h2 id="4-Spring-Security-核心-API"><a href="#4-Spring-Security-核心-API" class="headerlink" title="4. Spring Security 核心 API"></a>4. Spring Security 核心 API</h2><h3 id="4-1-Authentication"><a href="#4-1-Authentication" class="headerlink" title="4.1. Authentication"></a>4.1. Authentication</h3><p><code>Authentication</code> 是 Spring Security 中的核心接口，负责封装用户的身份信息和认证数据，其源码定义如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Authentication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Principal</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br><br>	<span class="hljs-comment">// 用户拥有的权限集合，比如 [&quot;ROLE_USER&quot;, &quot;ROLE_ADMIN&quot;]</span><br>    Collection&lt;? <span class="hljs-keyword">extends</span> GrantedAuthority&gt; getAuthorities();<br><br>	<span class="hljs-comment">// 用户的密码，一般设置为 null</span><br>    <span class="hljs-function">Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">// 请求附加信息，比如客户端 IP、会话 ID，以及其他自定义信息</span><br>    <span class="hljs-function">Object <span class="hljs-title">getDetails</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">// 用户对象，即 UserDetails 对象，比如 CustomerUserDetailsImpl</span><br>    <span class="hljs-function">Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">// 用户是否已经过认证（true 表示认证的 Authentication，false 表示匿名的 Authentication）</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isAuthenticated</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">// 用于手动设置用户是否认证（只能将 true 设置为 false，不能将 false 设置为 true）</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAuthenticated)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该接口有多种实现类，其中最常用的是 <code>UsernamePasswordAuthenticationToken</code>，用于表示已认证用户的身份认证信息（<code>AuthenticationManager</code> 默认使用的就是这种）；而 <code>AnonymousAuthenticationToken</code> 则常用于表示匿名用户的身份（<code>AnonymousAuthenticationFilter</code> 默认使用的就是这种）。</p>
<p>我们常说将 <code>Authentication</code> 放入线程中，如果不通过 <code>AuthenticationManager</code> 来完成认证流程，而是手动构造并设置一个 <code>Authentication</code> 对象，通常做法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 加载用户信息  </span><br><span class="hljs-type">UserDetails</span> <span class="hljs-variable">userDetails</span> <span class="hljs-operator">=</span> userDetailsService.loadUserByUsername(username);<br><br><br><span class="hljs-comment">// 2. 创建 Authentication 对象（选择一个合适的实现类，创建实现类的对象）  </span><br><span class="hljs-type">UsernamePasswordAuthenticationToken</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernamePasswordAuthenticationToken</span>( userDetails, <span class="hljs-literal">null</span>, userDetails.getAuthorities() );  <br><br><br><span class="hljs-comment">// 3. 设置请求附加信息</span><br>auth.setDetails(自定义类的对象);  <br><br><br><span class="hljs-comment">// 4. 将认证信息存入本线程的安全上下文  </span><br>SecurityContextHolder.getContext().setAuthentication(auth);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>使用这种构造方式创建的 <code>Authentication</code> 对象，其 <code>isAuthenticated()</code> 默认为 <code>true</code>，因为构造函数中传入了权限（<code>authorities</code>），Spring Security 会自动将其标记为已认证。如果我们未传入权限，则默认为 <code>false</code>。</li>
<li>Spring Security <strong>不允许</strong>我们手动将 <code>isAuthenticated</code> 从 <code>false</code> 设置为 <code>true</code>。若希望构造一个 <code>isAuthenticated</code> 为 <code>true</code> 的 <code>Authentication</code> 对象，必须使用带权限参数的构造方法重新创建对象</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// isAuthenticated 为 false 的构造方法</span><br><span class="hljs-type">UsernamePasswordAuthenticationToken</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernamePasswordAuthenticationToken</span>( userDetails, <span class="hljs-literal">null</span> );  <br><br><br><span class="hljs-comment">// isAuthenticated 为 true 的构造方法</span><br><span class="hljs-type">UsernamePasswordAuthenticationToken</span> <span class="hljs-variable">auth</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernamePasswordAuthenticationToken</span>( userDetails, <span class="hljs-literal">null</span>, userDetails.getAuthorities() );  <br></code></pre></td></tr></table></figure>

<hr>
<h1 id="二、实操"><a href="#二、实操" class="headerlink" title="二、实操"></a>二、实操</h1><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><h3 id="1-1-基于-HttpSession-的-Spring-Security"><a href="#1-1-基于-HttpSession-的-Spring-Security" class="headerlink" title="1.1. 基于 HttpSession 的 Spring Security"></a>1.1. 基于 HttpSession 的 Spring Security</h3><h4 id="1-1-1-创建-Spring-Web-项目，添加相关依赖"><a href="#1-1-1-创建-Spring-Web-项目，添加相关依赖" class="headerlink" title="1.1.1. 创建 Spring Web 项目，添加相关依赖"></a>1.1.1. 创建 Spring Web 项目，添加相关依赖</h4><p>创建时：</p>
<ol>
<li>Web：<ol>
<li>Spring Web</li>
</ol>
</li>
<li>Security：<ol>
<li>Spring Security</li>
</ol>
</li>
<li>SQL<ol>
<li>JDBC API</li>
<li>MyBatis Framework</li>
<li>MySQL Driver</li>
</ol>
</li>
</ol>
<hr>
<h4 id="1-1-2-创建-用户-角色-权限-数据库表"><a href="#1-1-2-创建-用户-角色-权限-数据库表" class="headerlink" title="1.1.2. 创建 用户-角色-权限 数据库表"></a>1.1.2. 创建 用户-角色-权限 数据库表</h4><p>我们一般会创建五个表：<code>users</code> 表（用户表）存储所有注册用户的信息，<code>roles</code> 表（角色表）定义了系统中存在的各种角色，<code>user_role</code> 表（用户-角色关联表）用于建立用户和角色之间的多对多关系，<code>authorities</code> 表（权限表）定义了系统中的各种操作权限，<code>role_authoritie</code> 表（角色-权限表）用于建立角色和权限之间的多对多关系</p>
<p><font color="#92d050">1. users 表（用户表）</font></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>数据类型</th>
<th>约束</th>
<th>索引</th>
<th>默认值</th>
<th>示例值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>user_id</strong></td>
<td>int</td>
<td>主键约束、自增属性</td>
<td>主键索引</td>
<td>自增</td>
<td>1</td>
<td>用户唯一标识符（将 username 直接作为主键也是一种常见做法）</td>
</tr>
<tr>
<td><strong>username</strong></td>
<td>varchar(20)</td>
<td>唯一约束</td>
<td>唯一索引</td>
<td></td>
<td>john</td>
<td>用户名</td>
</tr>
<tr>
<td><strong>password</strong></td>
<td>varchar(80)</td>
<td></td>
<td></td>
<td></td>
<td>$2a$10$abcdefghijklmnopqrstuvwxyz</td>
<td>加密后密码，推荐长度设的长一些，以兼容现代加密算法（禁止明文密码直接入库）</td>
</tr>
<tr>
<td><strong>is_accountNonExpired</strong></td>
<td>tinyint(1)</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td>账户是否没过期（1 代表没过期）</td>
</tr>
<tr>
<td><strong>is_accountNonLocked</strong></td>
<td>tinyint(1)</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td>账户是否没锁定</td>
</tr>
<tr>
<td><strong>is_credentialsNonExpired</strong></td>
<td>tinyint(1)</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td>密码是否没过期</td>
</tr>
<tr>
<td><strong>is_enabled</strong></td>
<td>tinyint(1)</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td>用户是否启用</td>
</tr>
<tr>
<td><strong>email</strong></td>
<td>VARCHAR(20)</td>
<td>唯一约束</td>
<td>唯一索引</td>
<td></td>
<td><a href="mailto:&#106;&#x6f;&#x68;&#110;&#x40;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;">&#106;&#x6f;&#x68;&#110;&#x40;&#101;&#x78;&#97;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;</a></td>
<td>邮箱</td>
</tr>
<tr>
<td><strong>phone_number</strong></td>
<td>VARCHAR(20)</td>
<td>唯一约束</td>
<td>唯一索引</td>
<td></td>
<td>13800138000</td>
<td>电话号码</td>
</tr>
</tbody></table>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-number">1.</span> 创建表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> users (<br>    user_id <span class="hljs-type">INT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY KEY</span>,<br>    username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    <span class="hljs-keyword">password</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">80</span>),<br>    is_accountNonExpired TINYINT(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,<br>    is_accountNonLocked TINYINT(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,<br>    is_credentialsNonExpired TINYINT(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,<br>    is_enabled TINYINT(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,<br>    email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    phone_number <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>)<br>) ENGINE=InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8mb4;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> users <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> unique_username <span class="hljs-keyword">UNIQUE</span> (username);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> users <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> unique_email <span class="hljs-keyword">UNIQUE</span> (email);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> users <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> unique_phone <span class="hljs-keyword">UNIQUE</span> (phone_number);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>username、password、isAccountNonExpired、isAccountNonLocked、isCredentialsNonExpired、isEnabled、authorities 这七个字段是 <code>userDetails</code> 接口的默认属性，一般在数据库表中要全部包含</li>
<li>email、phone_number 等字段，是我们自己扩展的字段。</li>
<li>虽然 camelCase 在 Java 中使用广泛，例如 phoneNumber，但在 SQL 表列名中更建议统一为 snake_case，例如 phone_number</li>
</ol>
</blockquote>
<p><font color="#92d050">2. roles 表（角色表）</font></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>数据类型</th>
<th>约束</th>
<th>默认值</th>
<th>索引</th>
<th>示例值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>role_id</strong></td>
<td>int</td>
<td>主键约束、自增属性</td>
<td>自增</td>
<td>主键索引</td>
<td>1</td>
<td>角色唯一标识符</td>
</tr>
<tr>
<td><strong>role_name</strong></td>
<td>varchar(20)</td>
<td>唯一约束</td>
<td></td>
<td>唯一索引</td>
<td>ROLE_ADMIN</td>
<td>角色名称，推荐全大写的格式 (Spring Security 约定以 <code>ROLE_</code> 开头)</td>
</tr>
</tbody></table>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-number">1.</span> 创建表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> roles (<br>    role_id <span class="hljs-type">INT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY KEY</span>,<br>    role_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">UNIQUE</span><br>) <span class="hljs-keyword">COMMENT</span>=<span class="hljs-string">&#x27;角色表&#x27;</span>;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> roles <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> unique_role_name <span class="hljs-keyword">UNIQUE</span> (role_name);<br><br><br># <span class="hljs-number">2.</span> 插入数据<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> roles (role_name) <span class="hljs-keyword">VALUES</span> <br>	(<span class="hljs-string">&#x27;ROLE_ADMIN&#x27;</span>),<br>	(<span class="hljs-string">&#x27;ROLE_USER&#x27;</span>);<br></code></pre></td></tr></table></figure>


<p><font color="#92d050">3. user_role 表（用户-角色关联表）</font></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>数据类型</th>
<th>约束</th>
<th>索引</th>
<th>默认值</th>
<th>示例值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>user_id</strong></td>
<td>int</td>
<td>主键约束（与 role_id 联合主键）<br>外键约束（指向 users 表中的 user_id）</td>
<td>联合主键索引</td>
<td></td>
<td>1</td>
<td>users 表中的 id</td>
</tr>
<tr>
<td><strong>role_id</strong></td>
<td>int</td>
<td>主键约束（与 user_id 联合主键）<br>外键约束（指向 roles 表中的 role_id）</td>
<td>联合主键索引</td>
<td></td>
<td>1</td>
<td>roles 表中的 id</td>
</tr>
</tbody></table>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas"># 1. 创建表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> user_role (<br>    user_id    INT         <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    role_id    INT         <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">KEY</span> (user_id, role_id),<br>    <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (user_id) <span class="hljs-keyword">REFERENCES</span> users (user_id),<br>    <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (role_id) <span class="hljs-keyword">REFERENCES</span> roles (role_id)<br>) ;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>两表的关联表，一般是取其两表名的单数形式，以 <code>_</code> 进行衔接</li>
</ol>
</blockquote>
<p><font color="#92d050">4. authorities 表（权限表）</font></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>数据类型</th>
<th>约束</th>
<th>索引</th>
<th>默认值</th>
<th>示例值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>authority_id</strong></td>
<td>int</td>
<td>主键约束、自增属性</td>
<td>主键索引</td>
<td>自增</td>
<td>1</td>
<td>权限唯一标识</td>
</tr>
<tr>
<td><strong>authority_name</strong></td>
<td>varchar(50)</td>
<td>唯一约束</td>
<td>唯一索引</td>
<td></td>
<td>finance:invoice:approve</td>
<td>权限名称，推荐全小写的格式（常采用 模块：资源：操作 的命名方式）</td>
</tr>
</tbody></table>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-number">1.</span> 创建表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> authorities (<br>    authority_id <span class="hljs-type">INT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY KEY</span>,<br>    authority_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>) ENGINE=InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8mb4;<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> authorities <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> unique_authority_name <span class="hljs-keyword">UNIQUE</span> (authority_name);<br><br><br># <span class="hljs-number">2.</span> 插入数据<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> authorities (authority_name) <span class="hljs-keyword">VALUES</span><br>    (<span class="hljs-string">&#x27;test:test:test&#x27;</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>表名叫做 <code>authorities</code>，列名叫做 <code>authority_xxx</code></li>
</ol>
</blockquote>
<p><font color="#92d050">5. role_authority 表（角色-权限关联表）</font></p>
<table>
<thead>
<tr>
<th>列名</th>
<th>数据类型</th>
<th>约束</th>
<th>索引</th>
<th>默认值</th>
<th>示例值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>role_id</strong></td>
<td>int</td>
<td>主键约束（与 authoritie_id 联合主键）<br>外键约束（指向 roles 表中的 role_id）</td>
<td>联合主键索引</td>
<td></td>
<td>1</td>
<td>roles 表中的 id</td>
</tr>
<tr>
<td><strong>authority_id</strong></td>
<td>int</td>
<td>主键约束（与 role_id 联合主键）<br>外键约束（指向 authorities 表中的 authoritie_id）</td>
<td>联合主键索引</td>
<td></td>
<td>1</td>
<td>authorities 表中的 id</td>
</tr>
</tbody></table>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># <span class="hljs-number">1.</span> 创建表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> role_authority (<br>    role_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    authority_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY KEY</span> (role_id, authority_id),<br>    <span class="hljs-keyword">FOREIGN KEY</span> (role_id) <span class="hljs-keyword">REFERENCES</span> roles(role_id),<br>    <span class="hljs-keyword">FOREIGN KEY</span> (authority_id) <span class="hljs-keyword">REFERENCES</span> authorities(authority_id)<br>) ;<br><br><br># <span class="hljs-number">2.</span> 插入数据<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> role_authority (role_id, authority_id) <span class="hljs-keyword">VALUES</span><br>    (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>五张表符合 RBAC 规范，详见下文：RBAC 规范</li>
</ol>
</blockquote>
<hr>
<h4 id="1-1-3-使用-Spring-Data-MyBatis-实现查询用户的基本信息和权限"><a href="#1-1-3-使用-Spring-Data-MyBatis-实现查询用户的基本信息和权限" class="headerlink" title="1.1.3. 使用 Spring Data MyBatis 实现查询用户的基本信息和权限"></a>1.1.3. 使用 Spring Data MyBatis 实现查询用户的基本信息和权限</h4><h5 id="1-1-3-1-进行-MyBatis-相关配置"><a href="#1-1-3-1-进行-MyBatis-相关配置" class="headerlink" title="1.1.3.1. 进行 MyBatis 相关配置"></a>1.1.3.1. 进行 MyBatis 相关配置</h5><p>详见笔记：Spring Data MyBatis</p>
<hr>
<h5 id="1-1-3-2-编写-User-Entity-类"><a href="#1-1-3-2-编写-User-Entity-类" class="headerlink" title="1.1.3.2. 编写 User Entity 类"></a>1.1.3.2. 编写 User Entity 类</h5><p>User 类位于 <code>com.example.securitywithhttpsession.entity</code> 包下</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> class User &#123;<br><br>	<span class="hljs-comment">// users 表中的数据（用户基本信息）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Integer</span> userId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Integer</span> isAccountNonExpired;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Integer</span> isAccountNonLocked;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Integer</span> isCredentialsNonExpired;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Integer</span> isEnabled;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> email;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> phoneNumber;<br>    <br>	<span class="hljs-comment">// authorities 表中的数据（用户的权限，不要忘记添加这个）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">List</span>&lt;SimpleGrantedAuthority&gt; authorities;<br><br>	<span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-comment">// getter 方法</span><br>	<span class="hljs-comment">// setter 方法</span><br>	<span class="hljs-comment">// equals 方法</span><br>	<span class="hljs-comment">// hashCode 方法</span><br>	<span class="hljs-comment">// toString 方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>与数据库表映射的类，通常称为 Entity 类，也可称为 DO 类或 PO 类，统属 POJO 类，通常只包含 getter、setter 、equals、hashCode、toString 方法及构造方法，不应包含业务逻辑方法</li>
<li>这里写 Integer 其实不太好，最好的是写 Boolean，但是也不影响，详见下文：实现 UserDetails 接口</li>
<li>使用 MyBatisX 插件生成的 POJO 类默认包含 getter、setter、equals、hashCode、toString 方法，但不包含构造方法。<ol>
<li>我们可以手动补全有参和无参构造方法；</li>
<li>同时我么也可以删除自动生成的 equals、hashCode、toString 方法，改为使用 IDEA 生成</li>
</ol>
</li>
<li>本 User 类不仅与 Users 表映射，还包含了 authorities 表中的 <code>authoritie_name</code> 字段。因此，别忘了添加 <code>private List&lt;String&gt; authorities;</code> 及其对应的方法（包括 getter、setter、equals、hashCode、toString 方法以及构造方法）</li>
<li>数据库中的表名一般使用复数形式，如 users，而在 Java 中则采用单数形式命名，如 User</li>
</ol>
</blockquote>
<p><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9ASpring%20Security/image-20250630183241212.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h5 id="1-1-3-3-编写-UserMapper-接口，并定义查询方法"><a href="#1-1-3-3-编写-UserMapper-接口，并定义查询方法" class="headerlink" title="1.1.3.3. 编写 UserMapper 接口，并定义查询方法"></a>1.1.3.3. 编写 UserMapper 接口，并定义查询方法</h5><p>UserMapper 类位于 <code>com.example.securitywithhttpsession.mapper</code> 包下</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Mapper</span>  <br>public interface UserMapper &#123;  <br><br>    <span class="hljs-selector-tag">User</span> <span class="hljs-selector-tag">getUserByUserName</span>(<span class="hljs-variable">@Param</span>(<span class="hljs-string">&quot;username&quot;</span>) String username) ;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="1-1-3-4-编写查询方法对应的-SQL-语句（编写-UserMapper-xml）"><a href="#1-1-3-4-编写查询方法对应的-SQL-语句（编写-UserMapper-xml）" class="headerlink" title="1.1.3.4. 编写查询方法对应的 SQL 语句（编写 UserMapper.xml）"></a>1.1.3.4. 编写查询方法对应的 SQL 语句（编写 UserMapper.xml）</h5><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span></span><br><span class="hljs-meta"><span class="language-xml">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="hljs-meta"><span class="language-xml">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.securitywithhttpsession.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.example.securitywithhttpsession.entity.User&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;isAccountnonexpired&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;is_accountNonExpired&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;TINYINT&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;isAccountnonlocked&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;is_accountNonLocked&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;TINYINT&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;isCredentialsnonexpired&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;is_credentialsNonExpired&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;TINYINT&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;isEnabled&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;is_enabled&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;TINYINT&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;phoneNumber&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;phone_number&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 不要忘记添加 authorities 的映射关系 --&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;authorities&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;org.springframework.security.core.authority.SimpleGrantedAuthority&quot;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">constructor</span>&gt;</span></span><br><span class="language-xml">                    <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;authority_name&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;/<span class="hljs-name">constructor</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUserName&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span>&gt;</span></span><br><span class="language-xml">        SELECT</span><br><span class="language-xml">            users.user_id,</span><br><span class="language-xml">            users.username,</span><br><span class="language-xml">            users.password,</span><br><span class="language-xml">            users.is_accountNonExpired,</span><br><span class="language-xml">            users.is_accountNonLocked,</span><br><span class="language-xml">            users.is_credentialsNonExpired,</span><br><span class="language-xml">            users.is_enabled,</span><br><span class="language-xml">            users.email,</span><br><span class="language-xml">            users.phone_number,</span><br><span class="language-xml">            authorities.authority_name</span><br><span class="language-xml">        FROM users</span><br><span class="language-xml">                 LEFT JOIN user_role ON users.user_id = user_role.user_id</span><br><span class="language-xml">                 LEFT JOIN role_authority ON user_role.role_id = role_authority.role_id</span><br><span class="language-xml">                 LEFT JOIN authorities ON role_authority.authority_id = authorities.authority_id</span><br><span class="language-xml">        WHERE users.username = #</span><span class="hljs-template-variable">&#123;username&#125;</span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li><code>username</code>、<code>password</code>、<code>is_accountNonExpired</code>、<code>is_accountNonLocked</code>、<code>is_credentialsNonExpired</code>、<code>is_enabled</code> 以及 <code>authority_name</code> 是必须要查询的字段，因为这些字段会被封装到 <code>CustomerUserDetailsImpl</code> 中，供 Spring Security 进行认证与授权使用。</li>
<li>其他字段是否查询，可以根据实际需求灵活决定。即使你没有将 <code>email</code>、<code>phoneNumber</code> 等扩展信息封装进 <code>CustomerUserDetailsImpl</code>，这个方法依然可以作为一个通用的用户信息查询入口来使用。比如你后续业务中需要查询 <code>email</code> ，完全也可以直接调用这个方法。换句话说，这个方法不仅仅是在封装 <code>CustomerUserDetailsImpl</code> 时用得上，未来在其他场景中也很可能会复用，所以稍微 “富余” 一些是没问题的。</li>
</ol>
</blockquote>
<hr>
<h4 id="1-1-4-实现-UserDetails-接口"><a href="#1-1-4-实现-UserDetails-接口" class="headerlink" title="1.1.4. 实现 UserDetails 接口"></a>1.1.4. 实现 UserDetails 接口</h4><p>我们通常会定义一个类 <code>CustomerUserDetailsImpl</code> 来实现 Spring Security 提供的 <code>UserDetails</code> 接口。那么，这个类到底是做什么用的呢？我们先来看一下 <code>UserDetails</code> 接口的源码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Serializable</span> &#123;  <br><br>	<span class="hljs-comment">// 获取用户权限集合</span><br>    <span class="hljs-title class_">Collection</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GrantedAuthority</span>&gt; <span class="hljs-title function_">getAuthorities</span>();  <br>    <br>    <span class="hljs-comment">// 获取密码（加密后的密码）</span><br>    <span class="hljs-title class_">String</span> <span class="hljs-title function_">getPassword</span>();  <br>    <br>	<span class="hljs-comment">// 获取用户名（如 &quot;admin&quot;）</span><br>    <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUsername</span>();  <br>    <br>	<span class="hljs-comment">// 账户是否没过期（true 代表没过期，false 代表过期）</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isAccountNonExpired</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 默认返回 true</span><br>    &#125;  <br>    <span class="hljs-comment">// 账户是否没锁定</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isAccountNonLocked</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 凭证（密码）是否没过期</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isCredentialsNonExpired</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>    <span class="hljs-comment">// 账户是否启用</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isEnabled</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>Spring Security 是通过调用 <code>UserDetails</code> 接口中定义的方法来获取用户信息的（毕竟 Spring Security 并不了解你项目中具体使用了什么类、字段名是什么，对吧，所以不会直接从我们的 User Entity 中拿数据）。</p>
<p>但我们也注意到，<code>UserDetails</code> 毕竟只是一个接口，它的方法并没有默认实现和返回值。也就是说，当 Spring Security 调用这些接口方法时，由于接口本身没有具体实现，自然无法拿到到任何值。这也正是我们为什么需要实现一个 <code>CustomUserDetailsImpl</code> 类来实现这个接口的原因。我们必须为接口中的每个方法提供具体实现，确保它们能返回对应的值，这样当 Spring Security 调用这些方法时，才能拿到用户信息。</p>
<p>其实我们也发现了，像 <code>isAccountNonExpired()</code>、<code>isAccountNonLocked()</code>、<code>isCredentialsNonExpired()</code>、<code>isEnabled()</code> 这几个方法，Spring Security 是提供了默认值的；但另外三个关键方法（如 <code>getUsername()</code>、<code>getPassword()</code>、<code>getAuthorities()</code>）是没有默认实现的，也就是说我们至少必须实现这三个方法，否则编译会直接报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerUserDetailsImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetails</span> &#123;  <br><br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Collection</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GrantedAuthority</span>&gt; <span class="hljs-title function_">getAuthorities</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getPassword</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUsername</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isAccountNonExpired</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">UserDetails</span>.<span class="hljs-property">super</span>.<span class="hljs-title function_">isAccountNonExpired</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isAccountNonLocked</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">UserDetails</span>.<span class="hljs-property">super</span>.<span class="hljs-title function_">isAccountNonLocked</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isCredentialsNonExpired</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">UserDetails</span>.<span class="hljs-property">super</span>.<span class="hljs-title function_">isCredentialsNonExpired</span>();  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isEnabled</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">UserDetails</span>.<span class="hljs-property">super</span>.<span class="hljs-title function_">isEnabled</span>();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>那我们为什么非得实现 <code>UserDetails</code> 呢？你说 Spring Security 知不知道这些值，关我什么事？我自己知道就行了呗。但其实你仔细一想，我们就能发现 Spring Security 这么设计是有它的道理的，核心原因就在于：Spring Security 的整个认证和授权流程，底层都是围绕一个 <code>Authentication</code> 对象来构建的，而这个对象的核心信息，其实都来自我们实现的 <code>CustomerUserDetailsImpl</code></p>
<p>我们必须要搞清楚以下几点：</p>
<ol>
<li>Spring Security 是通过 <code>CustomerUserDetailsImpl</code> 来构建 <code>Authentication</code> 对象的</li>
<li>在登录流程中，通常有两种典型的方式：<ol>
<li>通过 <code>AuthenticationManager</code> 进行认证（自定义登录 API，使用 AuthenticationManager 进行认证逻辑）：<ol>
<li>Spring Security 会自动去校验用户提交的用户名和密码，是否与 <code>CustomerUserDetailsImpl</code> 中提供的用户名和密码相匹配；</li>
<li>如果匹配成功，Spring Security 就会自动将 <code>CustomerUserDetailsImpl</code> 封装为一个 <code>Authentication</code> 对象，并存入当前线程；</li>
<li>校验的时候，用户信息是从 <code>CustomerUserDetailsImpl</code> 中读取的，封装为 <code>Authentication</code> 对象的时候，其值也是从此读取的。</li>
<li>需要注意的是：这个过程中 Spring Security 还会自动帮你判断用户是否启用、是否锁定、密码是否过期等等。如果你选择下面的手动认证逻辑，那这些判断就必须你自己来实现。</li>
</ol>
</li>
<li>自定义认证逻辑（自定义登录 API，不用 <code>AuthenticationManager</code>，自己写认证逻辑）：<ol>
<li>你仍然需要自己去校验前端提交的用户名和密码，和 <code>CustomerUserDetailsImpl</code> 中提供的数据是否一致；</li>
<li>验证通过后，你需要手动将 <code>CustomerUserDetailsImpl</code> 封装为一个 <code>Authentication</code> 对象，并保存到当前线程中；</li>
<li>其实在校验阶段，用户名和密码放不放到 <code>CustomerUserDetailsImpl</code> 中都无所谓，你甚至可以直接从<code>User Entity</code> 中拿值来对比。更高级一点，你也可以使用扫码登录、验证码、OAuth2 等方式，不再局限于用户名密码；</li>
<li>但是，一旦你需要构建 <code>Authentication</code>，你最终还是得使用 <code>CustomUserDetailsImpl</code>，因为 <code>Authentication</code> 中的数据必须要从它那里来。</li>
<li>所以我们可以得出一个结论：在认证过程中不一定非得依赖 <code>CustomerUserDetailsImpl</code>，但在封装 <code>Authentication</code> 的过程中，最终数据必须来自这个实现类。</li>
</ol>
</li>
</ol>
</li>
<li>最后就是权限判断的问题。权限判断是根据当前线程中保存的 <code>Authentication</code> 对象来进行的，而这个对象里的权限信息，不就是我们 <code>CustomerUserDetailsImpl</code> 的 <code>getAuthorities()</code> 方法中返回的吗？所以说本质上这些权限数据，也都是从 <code>CustomerUserDetailsImpl</code> 里来的</li>
</ol>
<p>所以，如果我们使用了 Spring Security，那么实现 <code>CustomerUserDetailsImpl</code> 就显得尤为关键。那问题来了：我们到底是如何将 <code>UserMapper</code> 查询到的 <code>User</code> 对象中的信息，封装进 <code>CustomerUserDetailsImpl</code> 的？</p>
<p>首先思考下：如果是要把 <code>User</code> 对象中的属性同步到 <code>CustomerUserDetailsImpl</code> 中，我们一般会想到以下两种方式：</p>
<ol>
<li>显示赋值方式：<ol>
<li>我们可以先使用 <code>UserMapper</code> 查询出一个 <code>User</code> 对象，然后 <code>new</code> 一个 <code>CustomerUserDetailsImpl</code> 对象，接着再逐个地将 <code>User</code> 的属性赋值到这个对象中。这种方式直观易懂，但写起来繁琐冗长，尤其当字段较多时，容易出错。</li>
</ol>
</li>
<li>构造方法方式（推荐）：<ol>
<li>在 <code>CustomerUserDetailsImpl</code> 中定义一个以 <code>User</code> 为参数的构造方法，那么当我们 <code>new</code> 它的时候，直接传入一个 <code>User</code> 对象，构造函数内部再将 <code>User</code> 的各个属性赋值到当前对象中。这样封装更简洁、更优雅，也更利于后续维护</li>
</ol>
</li>
</ol>
<p>但这里我们需要特别注意一点：<code>CustomerUserDetailsImpl</code> 本质上并不是一个普通的属性容器（如果它只是一些简单的属性，那显式赋值和构造方法两种方式都可以使用）。它作为 <code>UserDetails</code> 的实现类，其核心职责是通过方法的返回值来向 Spring Security 暴露用户信息的（也就是说，它的用户数据并不是通过公共属性暴露的，而是通过接口方法提供的）</p>
<p>因此，我们在封装时更适合采用构造方法的方式。具体来说，就是在 <code>CustomerUserDetailsImpl</code> 中定义一个接收 <code>User</code> 对象的构造函数，在构造函数中将该 <code>User</code> 对象保存为内部私有字段。然后在 <code>getUsername()</code>、<code>getPassword()</code>、<code>getAuthorities()</code> 等方法中，直接返回这个 <code>User</code> 对象中的相应属性值，大致如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerUserDetailsImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetails</span> &#123;<br><br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">User</span> user;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">CustomerUserDetailsImpl</span>(<span class="hljs-title class_">User</span> user) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = user;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUsername</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getUsername</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getPassword</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getPassword</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Collection</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GrantedAuthority</span>&gt; <span class="hljs-title function_">getAuthorities</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getAuthorities</span>(); <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isAccountNonExpired</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getIsAccountnonexpired</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isAccountNonLocked</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getIsAccountnonlocked</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isCredentialsNonExpired</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getIsCredentialsnonexpired</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isEnabled</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getIsEnabled</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那我们写好这个类之后，只需要在某个方法中，先通过 <code>UserMapper</code> 查询出一个 <code>User</code> 对象，然后直接执行 <code>new CustomerUserDetailsImpl(user)</code>，就能创建出一个封装了用户信息的 <code>CustomerUserDetailsImpl</code> 实例。</p>
<p>其实这个步骤，Spring Security 早已帮我们考虑好了，它已经提供了一个专门的接口：<code>UserDetailsService</code>。我们只需要实现这个接口，并重写它的 <code>loadUserByUsername</code> 方法，在这个方法中使用 <code>UserMapper</code> 查询出对应的 <code>User</code>，然后直接 <code>return new CustomerUserDetailsImpl(user)</code> 即可。</p>
<p>这样一来，当我们调用这个方法的时候，它就会执行查询用户信息，并返回一个包含完整用户数据的 <code>CustomerUserDetailsImpl</code> 对象，供后续构建 <code>Authentication</code> 使用。</p>
<p>需要注意的是，<code>CustomerUserDetailsImpl</code> 并不属于传统意义上的三层架构（Controller-Service-Repository），严格来说，它应当放置在 <code>com.example.securitywithhttpsession.entity</code> 包下，作为用户实体信息的一个安全扩展模型。</p>
<p>此外，Spring Security 提供的 <code>UserDetails</code> 接口默认只包含七个核心字段：<code>username</code>、<code>password</code>、<code>isAccountNonExpired</code>、<code>isAccountNonLocked</code>、<code>isCredentialsNonExpired</code>、<code>isEnabled</code> 和 <code>authorities</code>。</p>
<p>如果你希望在 <code>Authentication</code> 中携带更多的信息（例如 <code>email</code> 和 <code>phoneNumber</code>），是可以通过扩展 <code>CustomerUserDetailsImpl</code> 来实现的。这样做的好处是：你可以直接从 <code>SecurityContext</code> 中获取 <code>Authentication</code>，再从中获取这些扩展信息，无需再根据 <code>username</code> 查询数据库。这种方式在某些业务中能显著简化逻辑，提高效率。</p>
<p>不过需要明确的是，Spring Security 的设计初衷并不是鼓励我们将过多的用户字段直接放进 <code>Authentication</code> 对象中。是否将这些字段一并封装，应该根据你的具体业务场景权衡决定，避免过度冗余或信息泄露风险。</p>
<p>CustomerUserDetailsImpl 类在<code>com.example.securitywithhttpsession.entity</code> 包下，最终，我们实现的代码就如下所示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerUserDetailsImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetails</span> &#123;<br><br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">User</span> user;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">CustomerUserDetailsImpl</span>(<span class="hljs-title class_">User</span> user) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = user;<br>    &#125;<br><br>    <span class="hljs-comment">// 必须实现的 3 个方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Collection</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GrantedAuthority</span>&gt; <span class="hljs-title function_">getAuthorities</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getAuthorities</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getPassword</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getPassword</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUsername</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getUsername</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 可选择实现的 4 个方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isAccountNonExpired</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getIsAccountnonexpired</span>() != <span class="hljs-literal">null</span> &amp;&amp; user.<span class="hljs-title function_">getIsAccountnonexpired</span>() != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isAccountNonLocked</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getIsAccountnonlocked</span>() != <span class="hljs-literal">null</span> &amp;&amp; user.<span class="hljs-title function_">getIsAccountnonlocked</span>() !=<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isCredentialsNonExpired</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getIsCredentialsnonexpired</span>() != <span class="hljs-literal">null</span> &amp;&amp; user.<span class="hljs-title function_">getIsCredentialsnonexpired</span>() != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isEnabled</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getIsEnabled</span>() != <span class="hljs-literal">null</span> &amp;&amp; user.<span class="hljs-title function_">getIsEnabled</span>() != <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 选择性扩展的字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getEmail</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getEmail</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getPhoneNumber</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getPhoneNumber</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>由于我们的 <code>User</code> 中字段是 <code>private Integer isAccountNonExpired;</code>，而接口方法 <code>public boolean isAccountNonExpired()</code> 需要返回 boolean 类型，所以在实现时必须手动判断，如：<code>return user.getIsAccountNonExpired() != null &amp;&amp; user.getIsAccountNonExpired() != 0;</code></li>
<li>其实没必要这么复杂，主要原因是我们在 <code>User</code> 中使用了 Integer 类型。对于 MyBatis，如果你把字段声明成 <code>private boolean isAccountNonExpired;</code> 在相同的 SQL 语句下，它会自动把数据库中的 TINYINT(1) 映射成 boolean 类型，这样我们只需直接返回：<code>return user.isAccountNonExpired();</code></li>
<li>这样写就不需要额外判断了，而且更简洁，也比较推荐。但既然代码已经写成这样，我们就保持现有实现，下面给你展示这种推荐的写法：</li>
</ol>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// User Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>	<span class="hljs-comment">// users 表中的数据（用户基本信息）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Integer</span> userId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Boolean</span> isAccountNonExpired;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Boolean</span> isAccountNonLocked;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Boolean</span> isCredentialsNonExpired;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Boolean</span> isEnabled;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> email;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> phoneNumber;<br>    <br>	<span class="hljs-comment">// authorities 表中的数据（用户的权限，不要忘记添加这个）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">SimpleGrantedAuthority</span>&gt; authorities;<br><br>    <span class="hljs-comment">// getter 方法</span><br>	<span class="hljs-comment">// setter 方法</span><br>	<span class="hljs-comment">// equals 方法</span><br>	<span class="hljs-comment">// hashCode 方法</span><br>	<span class="hljs-comment">// toString 方法</span><br>&#125;<br><br><span class="hljs-comment">// CustomerUserDetailsImpl</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerUserDetailsImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetails</span> &#123;<br><br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">User</span> user;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">CustomerUserDetailsImpl</span>(<span class="hljs-title class_">User</span> user) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = user;<br>    &#125;<br><br>    <span class="hljs-comment">// 必须实现的 3 个方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Collection</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GrantedAuthority</span>&gt; <span class="hljs-title function_">getAuthorities</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getAuthorities</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getPassword</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getPassword</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUsername</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getUsername</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 可选择实现的 4 个方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isAccountNonExpired</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getIsAccountnonexpired</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isAccountNonLocked</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getIsAccountnonlocked</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isCredentialsNonExpired</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getIsCredentialsnonexpired</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">isEnabled</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getIsEnabled</span>();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 选择性扩展的字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getEmail</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getEmail</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getPhoneNumber</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> user.<span class="hljs-title function_">getPhoneNumber</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-5-实现-UserDetailsService-接口"><a href="#1-1-5-实现-UserDetailsService-接口" class="headerlink" title="1.1.5. 实现 UserDetailsService 接口"></a>1.1.5. 实现 UserDetailsService 接口</h4><p>我们一般创建 <code>CustomerUserDetailsImplService</code> 类，用于实现这个接口，并重写它的 <code>loadUserByUsername</code> 方法，在这个方法中使用 <code>UserMapper</code> 查询出对应的 <code>User</code>，然后直接 <code>return new CustomerUserDetailsImpl(user)</code> 即可。</p>
<p>CustomerUserDetailsImplService 类位于 <code>com.example.securitywithhttpsession.service</code> 包下</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerUserDetailsImplService</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">UserDetailsService</span></span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserDetails loadUserByUsername(<span class="hljs-keyword">String</span> username) throws UsernameNotFoundException &#123;<br>        User user = userMapper.getUserByUserName(username);<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span><span class="hljs-type"></span> UsernameNotFoundException(<span class="hljs-string">&quot;user not found&quot;</span> + username);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type"></span> CustomerUserDetailsImpl(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>写成 <code>private final UserMapper userMapper</code> 的话，就不能使用 <code>@Autowired</code> 这种方式进行注入，必须要使用构造注入的方式进行注入</li>
</ol>
</blockquote>
<hr>
<h4 id="1-1-6-进行-Spring-Security-配置"><a href="#1-1-6-进行-Spring-Security-配置" class="headerlink" title="1.1.6. 进行 Spring Security 配置"></a>1.1.6. 进行 Spring Security 配置</h4><p>详见上文：Spring Security 配置</p>
<hr>
<h4 id="1-1-7-编写-秘钥生成、加密、解密-工具类"><a href="#1-1-7-编写-秘钥生成、加密、解密-工具类" class="headerlink" title="1.1.7. 编写 秘钥生成、加密、解密 工具类"></a>1.1.7. 编写 秘钥生成、加密、解密 工具类</h4><p>这个密钥生成工具类用于创建 AES 对称加密所需的密钥、加密、解密，我们可以在保存数据时（如注册用户时），可以对如手机号、邮箱等敏感信息进行加密，并在需要时解密还原。  </p>
<p>我们常用的 <code>BCryptPasswordEncoder</code> 属于单向加密工具，无法还原原文，只能用于对加密结果进行比对验证，而这个工具，主要是加密那些不是特别敏感，但也比较敏感的信息，我们可以进行还原。</p>
<p>EncryptionUtils 类位于 <code>com.example.securitywithhttpsession.util</code> 包下，关于如何使用 Java 进行密钥生成、加密、解密，详见笔记：Java 生成密钥与加密解密</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncryptionUtils</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 1. 生成 Base64 编码后的 AES 密钥方法</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> <span class="hljs-title">generateSecretKey</span><span class="hljs-params">()</span> throws NoSuchAlgorithmException </span>&#123;<br>        <span class="hljs-comment">// 创建 AES 密钥生成器</span><br>        KeyGenerator keyGenerator = KeyGenerator.<span class="hljs-built_in">getInstance</span>(<span class="hljs-string">&quot;AES&quot;</span>);<br>        <span class="hljs-comment">// 指定密钥的位数，AES 支持 128、192、256 位</span><br>        keyGenerator.<span class="hljs-built_in">init</span>(<span class="hljs-number">256</span>);<br>        <span class="hljs-comment">// 生成密钥</span><br>        SecretKey secretKey = keyGenerator.<span class="hljs-built_in">generateKey</span>();<br>        <span class="hljs-comment">// 将密钥编码为 Base64 字符串</span><br>        <span class="hljs-keyword">return</span> Base<span class="hljs-number">64.</span><span class="hljs-built_in">getEncoder</span>().<span class="hljs-built_in">encodeToString</span>(secretKey.<span class="hljs-built_in">getEncoded</span>());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 2. 加密方法</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 传入参数：</span><br><span class="hljs-comment">     * - String plainText</span><br><span class="hljs-comment">     *      - 要加密的明文字符串</span><br><span class="hljs-comment">     * - String base64Key</span><br><span class="hljs-comment">     *      - Base64 编码后的 AES 密钥字符串</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-type">String</span> plainText, <span class="hljs-type">String</span> base64Key)</span> throws Exception </span>&#123;<br>    <br>        <span class="hljs-comment">// 把传入的 Base64 编码密钥转换为字节数组，供 AES 使用</span><br>        <span class="hljs-type">byte</span>[] keyBytes = Base<span class="hljs-number">64.</span><span class="hljs-built_in">getDecoder</span>().<span class="hljs-built_in">decode</span>(base64Key);<br>        <br>        <span class="hljs-comment">// 用字节数组创建一个 AES 对称密钥对象，供后续加密初始化使用</span><br>        SecretKeySpec secretKeySpec = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SecretKeySpec</span>(keyBytes, <span class="hljs-string">&quot;AES&quot;</span>);<br>        <br>        <span class="hljs-comment">// 获取 Cipher 实例，使用 AES 算法</span><br>        Cipher cipher = Cipher.<span class="hljs-built_in">getInstance</span>(<span class="hljs-string">&quot;AES&quot;</span>);<br>        <br>        <span class="hljs-comment">// 初始化加密器，设置为加密模式，并指定使用的密钥</span><br>        cipher.<span class="hljs-built_in">init</span>(Cipher.ENCRYPT_MODE, secretKeySpec);<br>        <br>        <span class="hljs-comment">// 执行加密，得到密文字节数组</span><br>        <span class="hljs-type">byte</span>[] encrypted = cipher.<span class="hljs-built_in">doFinal</span>(plainText.<span class="hljs-built_in">getBytes</span>());<br>        <br>        <span class="hljs-comment">// 把密文字节用 Base64 编码，便于作为字符串返回、存储或传输</span><br>        <span class="hljs-keyword">return</span> Base<span class="hljs-number">64.</span><span class="hljs-built_in">getEncoder</span>().<span class="hljs-built_in">encodeToString</span>(encrypted);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * 3. 解密密方法</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 传入参数：</span><br><span class="hljs-comment">     * - String encryptedText</span><br><span class="hljs-comment">     *      - 加密后的密文字符串</span><br><span class="hljs-comment">     * - String base64Key</span><br><span class="hljs-comment">     *      - Base64 编码后的 AES 密钥字符串</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> <span class="hljs-title">decrypt</span><span class="hljs-params">(<span class="hljs-type">String</span> encryptedText, <span class="hljs-type">String</span> base64Key)</span> throws Exception </span>&#123;<br>        <span class="hljs-type">byte</span>[] keyBytes = Base<span class="hljs-number">64.</span><span class="hljs-built_in">getDecoder</span>().<span class="hljs-built_in">decode</span>(base64Key);<br>        SecretKeySpec secretKeySpec = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SecretKeySpec</span>(keyBytes, <span class="hljs-string">&quot;AES&quot;</span>);<br>        Cipher cipher = Cipher.<span class="hljs-built_in">getInstance</span>(<span class="hljs-string">&quot;AES&quot;</span>);<br>        cipher.<span class="hljs-built_in">init</span>(Cipher.DECRYPT_MODE, secretKeySpec);<br>        <span class="hljs-type">byte</span>[] decrypted = cipher.<span class="hljs-built_in">doFinal</span>(Base<span class="hljs-number">64.</span><span class="hljs-built_in">getDecoder</span>().<span class="hljs-built_in">decode</span>(encryptedText));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(decrypted);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-8-编写-从线程获取-Authentication、CustomerUserDetailsImpl-工具类"><a href="#1-1-8-编写-从线程获取-Authentication、CustomerUserDetailsImpl-工具类" class="headerlink" title="1.1.8. 编写 从线程获取 Authentication、CustomerUserDetailsImpl 工具类"></a>1.1.8. 编写 从线程获取 Authentication、CustomerUserDetailsImpl 工具类</h4><p>AuthenticationUtils 类在 <code>com.example.securitywithhttpsession.util</code> 包下 </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthenticationUtils</span> &#123;<br>    <br>    <span class="hljs-comment">// 从本线程中获取 Authentication</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Authentication <span class="hljs-title">getAuthentication</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> SecurityContextHolder.getContext().getAuthentication();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 从本线程中获取 CustomerUserDetailsImpl</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CustomerUserDetailsImpl <span class="hljs-title">getCustomerUserDetailsImpl</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> (CustomerUserDetailsImpl) SecurityContextHolder.getContext().getAuthentication().getPrincipal();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="1-1-9-实现-注册-API、登录-API、授权-API、测试-API、注销-API"><a href="#1-1-9-实现-注册-API、登录-API、授权-API、测试-API、注销-API" class="headerlink" title="1.1.9. 实现 注册 API、登录 API、授权 API、测试 API、注销 API"></a>1.1.9. 实现 注册 API、登录 API、授权 API、测试 API、注销 API</h4><p>在 <code>com.example.securitywithhttpsession.controller</code> 下创建 <code>AuthController</code></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AuthenticationManager authenticationManager;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserRoleMapper userRoleMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TestService testService;<br><br>    <span class="hljs-comment">// 注册方法</span><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/public/signup&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String signUp(<span class="hljs-meta">@RequestBody</span> User user) &#123;<br>    <br>        String encodePassword = passwordEncoder.encode(user.getPassword());<br><br>        int i = userMapper.insertUser(user.getUsername(), encodePassword, user.getEmail(), user.getPhoneNumber());<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;服务器繁忙，请稍后再试&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户注册成功&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 登录方法</span><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/public/login&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String logIn(<span class="hljs-meta">@RequestParam(<span class="hljs-string">&quot;username&quot;</span>)</span> String username,<br>                        <span class="hljs-meta">@RequestParam(<span class="hljs-string">&quot;password&quot;</span>)</span> String password,<br>                        HttpServletRequest request,<br>                        HttpServletResponse response) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将 username 和 password 封装成 UsernamePasswordAuthenticationToken</span><br>            UsernamePasswordAuthenticationToken token =<br>                    new UsernamePasswordAuthenticationToken(username, password);<br><br>            <span class="hljs-comment">// 传递给 AuthenticationManager 进行认证</span><br>            Authentication auth = authenticationManager.authenticate(token);<br><br>            <span class="hljs-comment">// 将 Authentication 保存到当前线程的 SecurityContext</span><br>            SecurityContextHolder.getContext().setAuthentication(auth);<br><br>            <span class="hljs-comment">// 获取当前请求中的 CSRF Token（此 token 是 Spring Security 自动生成并放入 request 中的）</span><br>            CsrfToken csrfToken = (CsrfToken) request.getAttribute(CsrfToken.<span class="hljs-keyword">class</span>.getName());<br><br>            <span class="hljs-comment">// 将 token 返回给前端，常见做法是放入响应头，也可以放入响应体</span><br>            response.setHeader(<span class="hljs-string">&quot;X-CSRF-TOKEN&quot;</span>, csrfToken.getToken());<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录成功，欢迎用户：&quot;</span> + auth.getName();<br>        &#125; <span class="hljs-keyword">catch</span> (AuthenticationException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录失败，用户名或密码错误&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 授权方法</span><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/grantaccess&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String grantAccess(<span class="hljs-meta">@RequestParam(<span class="hljs-string">&quot;userid&quot;</span>)</span> int userid,<br>                              <span class="hljs-meta">@RequestParam(<span class="hljs-string">&quot;roleid&quot;</span>)</span> int roleid) &#123;<br>        int i = userRoleMapper.insertUserRole(userid, roleid);<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;服务器繁忙，请稍后再试&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功将 &quot;</span> + roleid + <span class="hljs-string">&quot; 授权给 &quot;</span> + userid;<br>    &#125;<br><br>    <span class="hljs-comment">// 测试方法</span><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/test&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String test() &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;正在执行只有 test:test:test 权限才能执行的 Service 方法&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;现在的 Authentication 信息如下：&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.println(AuthenticationUtils.getAuthentication());<br>        String testString = testService.test();<br>        <span class="hljs-keyword">return</span> testString;<br>    &#125;<br><br>    <span class="hljs-comment">// 注销方法</span><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/public/logOut&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; logout(HttpServletRequest request) &#123;<br>        <span class="hljs-comment">// 尝试获取 HttpSession，如果没有对应的 Session，就返回 null，不要新建 Session</span><br>        HttpSession session = request.getSession(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 使 session 失效，完成注销</span><br>            session.invalidate();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ResponseEntity.ok(<span class="hljs-string">&quot;用户已成功注销&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>配置了密码加密器后，AuthenticationManager 会将用户提交的密码加密并与数据库中查询出的密码进行匹配。如果数据库中仍是明文密码，将无法通过校验，返回“登录失败，用户名或密码错误”。</li>
<li>为了实现这些 API，我还另外书写了 UserRole.java、UserRoleMapper.java、UserRoleMapper.xml、TestService.java，并补充了 UserMapper.java、UserMapper.xml 详细请下载源码查看：summer&#x2F;SecurityWithHttpSession</li>
</ol>
</blockquote>
<hr>
<h3 id="1-2-基于-JWT-的-Spring-Security"><a href="#1-2-基于-JWT-的-Spring-Security" class="headerlink" title="1.2. 基于 JWT 的 Spring Security"></a>1.2. 基于 JWT 的 Spring Security</h3><h4 id="1-2-1-JWT-概述"><a href="#1-2-1-JWT-概述" class="headerlink" title="1.2.1. JWT 概述"></a>1.2.1. JWT 概述</h4><p>若是基于 HttpSession 的登录方式，如果后端服务器只有一台，那还算可行，但我们仍需关注诸如 CSRF 等安全风险。然而在现实应用中，后端服务器显然不可能只有一台，通常是多台服务器协同处理请求。在这种场景下，假如用户在登录时被负载均衡到服务器 1，并在该服务器上创建了 HttpSession，该服务器确实保存了用户的 Authentication 信息；但后续请求若被分配到服务器 2，由于该服务器并无用户的 Session 信息，就会导致用户“看似从未登录”，需要重新认证。同理，如果接下来被路由到服务器 3、服务器 4……难道用户每次都要重新登录？显然，在多服务器环境下，单纯依赖 HttpSession 并不可靠。此时，我们是否应当引入一种能够<strong>支持单点登录</strong>（SSO）的机制，来统一管理用户身份认证信息？</p>
<p>而 JWT（JSON Web Token）就能够实现单点登录，其核心价值在于：无需依赖服务器端的会话存储（如 <code>HttpSession</code>），便可安全地完成用户身份验证，并携带必要的用户信息进行传递。</p>
<p>JWT 由三部分组成：<strong>Header</strong>、<strong>Payload</strong> 和 <strong>Signature</strong>，中间用英文句点 <code>.</code> 分隔，形成 <code>xxxxx.yyyyy.zzzzz</code> 的格式，例如：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImNyZWF0ZWQiOjE1NTY3NzkxMjUzMDksImV4cCI6MTU1NzM4MzkyNX0.d-iki0193X0bBOETf2UN3r3PotNIEAV7mzIxxeI5IxFyzzkOZxS0PGfF_SK6wxCv2K8S0cZjMkv6b5bCqc0VBw<br></code></pre></td></tr></table></figure>

<p><font color="#92d050">1. Header（头部）</font><br>Header 用于声明该令牌的类型，这里是 JWT，以及 JWT 中用于生成和验证签名（即 Signature）的加密算法的种类（如 HMAC SHA256 或 RSA 等，作用于签名的算法）</p>
<p>其是一个 JSON 对象，通常长这样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// 表示签名使用的算法，如 HMAC SHA256</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span>        <span class="hljs-comment">// 表示类型是 JWT</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>在生成 JWT 时会对其进行 Base64URL 编码，形成：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9<br></code></pre></td></tr></table></figure>


<p><font color="#92d050">2. Payload（负载）</font><br>Payload 中一般包含两部分内容：第一部分是 Registered Claims，这是 JWT 推荐的标准字段，具有约定俗成的意义。这些字段虽然是可选的，但非常推荐使用，因为它们有助于后端进行有效的校验，比如判断 Token 是否已过期、是否有效、是否来自合法的客户端等。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>示例</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>iss</code></td>
<td><code>&quot;auth.myapp.com&quot;</code></td>
<td>表示签发者是谁</td>
</tr>
<tr>
<td><code>sub</code></td>
<td><code>&quot;user123&quot;</code></td>
<td>表示主题，通常用于标识用户身份（如用户 ID、用户名），实际中，可以选择不使用，而是在第二部分自定义字段来表示用户身份</td>
</tr>
<tr>
<td><code>aud</code></td>
<td><code>&quot;myapp-client&quot;</code></td>
<td>表示接收方是谁</td>
</tr>
<tr>
<td><code>exp</code></td>
<td><code>1710000000</code></td>
<td>表示过期时间，要以时间戳的形式</td>
</tr>
<tr>
<td><code>nbf</code></td>
<td><code>1709900000</code></td>
<td>表示生效时间，要以时间戳的形式</td>
</tr>
<tr>
<td><code>iat</code></td>
<td><code>1709890000</code></td>
<td>表示签发时间，要以时间戳的形式</td>
</tr>
<tr>
<td><code>jti</code></td>
<td><code>&quot;a-b-c-d-e&quot;</code></td>
<td>表示 JWT 的唯一标识 ID，用于防止重复</td>
</tr>
</tbody></table>
<p>第二部分是 Private Claims，这是根据业务场景自定义的数据字段，可以根据实际需求灵活添加。前端与后端需要对这些字段的格式和含义达成一致约定。例如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;userId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123456&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;alice&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;role&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;admin&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>最终，我们 JWT 的 Payload 写法如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;userId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123456&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;alice&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;role&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;admin&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;iat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1710000000</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;exp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1710003600</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>在生成 JWT 时会对其进行 Base64URL 编码，形成：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">eyJ<span class="hljs-number">1</span><span class="hljs-keyword">c</span><span class="hljs-number">2</span>VySWQiOiIxMjM<span class="hljs-number">0</span>NTYiLCJ<span class="hljs-number">1</span><span class="hljs-keyword">c</span><span class="hljs-number">2</span>VybmFtZSI<span class="hljs-number">6</span>ImFsaWNlIiwicm<span class="hljs-number">9</span>sZSI<span class="hljs-number">6</span>ImFkbWluIiwiaWF<span class="hljs-number">0</span>IjoxNzEwMDAwMDAwLCJleHAiOjE<span class="hljs-number">3</span>MTAwMDM<span class="hljs-number">2</span>MDB<span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>


<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>实际上，JWT 的 Payload 部分包含三类字段。除了我们前面提到的 Registered Claims 和 Private Claims 之外，还有一种是 Public Claims。这类字段也是自定义的，但需要遵循一定的命名规范（如使用 URI 命名空间），主要用于跨组织共享场景，在实际开发中，Public Claims 使用较少。</li>
</ol>
</blockquote>
<p><font color="#92d050">3. Signature（签名）</font><br>Signature 用于防止数据被篡改、伪造，验证数据完整性和来源，它的生成方式大致如下。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lisp">Signature = HMACSHA256(<br>  <span class="hljs-name">base64UrlEncode</span>(<span class="hljs-name">header</span>) + <span class="hljs-string">&quot;.&quot;</span> + base64UrlEncode(<span class="hljs-name">payload</span>),<br>  secret<br>)<br></code></pre></td></tr></table></figure>

<p>由前两部分的 Base64URL 编码拼接而成的字符串，会结合我们的密钥 <code>secret</code> 以及 Header 中指定的签名算法（<code>alg</code>）生成签名。</p>
<p>这个密钥是保存在我们的服务器中，当 JWT 被客户端发送回来时，服务器会使用这个密钥和签名算法对前两部分重新计算签名，并将其与 JWT 中附带的签名部分进行比对。如果比对一致，就说明该令牌未被篡改，可信；否则，说明令牌可能已被伪造或篡改，应视为无效。</p>
<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>对于 JWT 的安全性，我们必须对其进行了解：<ol>
<li>由于密钥是保存在服务器中的，只有你掌握，即使攻击者截获了 JWT，也无法伪造一个合法的 Token。因为即便他可以从 JWT 中解析出 Header 和 Payload，但没有你的密钥，就无法生成一个正确的签名。使用其他密钥伪造出来的签名，无法通过我们服务器使用原密钥重新计算的签名比对，因此验证会失败。</li>
<li>虽然 JWT 的 Header 和 Payload 看起来像一串很高端的字符，但实际上它们只是经过了 Base64URL 编码（注意不是 Base64 编码），目的是便于传输，并没有加密。因此任何人都可以解码查看其中的内容。例如在网站 <a target="_blank" rel="noopener" href="https://jwt.io/">https://jwt.io/</a> 上，就可以轻松将一个 JWT 解码并查看 Header 和 Payload 中的信息。</li>
<li>这也提醒我们：JWT 虽然具有防伪能力，能够有效防止前端伪造 Token，但由于其前两部分很容易被解码，因此不能将敏感信息（如密码、邮箱、手机号等）放入 Header 或 Payload 中。一般来说，像过期时间、生效时间、签发时间、用户 ID、用户名等信息已经足够。同时，为防止 Token 在传输过程中被截获，应通过 HTTPS 进行传输，而非明文 HTTP</li>
<li>如果攻击者真的截获了 JWT，在其未过期的有效时间内，是可以冒充用户发起请求的。如果系统只靠 Token 的签名来识别身份，因此无法判断是真用户还是伪装者。因此我们应尽量缩短 JWT 的有效期，例如设置为 15 分钟，以减小安全风险。</li>
<li>除此之外，我们还应配合一系列安全机制，辅助判断用户行为是否异常或存在风险。例如，在执行敏感操作时，可以要求用户进行额外验证，如输入身份证号码、手机验证码或进行人脸识别等，以增强身份校验的可靠性，这类多因子验证手段有助于防止 Token 被盗用后的非法操作，进一步提升系统的整体安全性。</li>
</ol>
</li>
<li>前端发送 JWT 的格式一般为：Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6…</li>
<li>我们一定要抛弃对 Cookie + HttpSession 的固有偏见，以及对 JWT 的祛魅：<ol>
<li>并非使用 Cookie 就不安全，关键在于合理配置 Cookie 属性，如 HttpOnly、Secure、SameSite 等。GitHub 实际上就是依赖 Cookie 来管理登录状态的。如果 Cookie 那么容易被截获，GitHub 官方又怎么会采用这种方案呢</li>
<li>有人认为 Cookie 容易被截获，但实际上，只要信息暴露在前端，无论是放在 LocalStorage 还是 Cookie，都存在被截获的风险，难道你使用 JWT 就没有被截获的风险了吗，要知道 JWT 也是需要保存在前端的，JWT 同样可能被截获，因为它暴露在前端。</li>
<li>那你说：JWT 能保证数据未被篡改。其实 Cookie 也可以做到，比如 Spring Security 的 RememberMe Cookie 就与 JWT 很类似。</li>
<li>实际上，Cookie 在某些方面甚至比 JWT 更灵活，例如在符合 OAuth 标准的授权服务器中，Spring Security 官方就推荐我们使用 RememberMe Cookie 实现登录，如果你非要使用 JWT 实现登录，那 Spring Security 也推荐你把 JWT 放在 Cookie 里，因为 Cookie 的自动携带特性能简化很多流程。</li>
<li>所以我们之所以选择拥抱 JWT，而不再采用 Cookie + HttpSession 的登录方式，其实我们真正抛弃的是 HttpSession。因为 HttpSession 天然依赖服务端状态，不适合后端多服务或分布式系统的场景，仅此而已。而 Cookie 本身依然是非常强大的机制。</li>
</ol>
</li>
</ol>
</blockquote>
<hr>
<h4 id="1-2-2-创建-Spring-Web-项目，添加相关依赖"><a href="#1-2-2-创建-Spring-Web-项目，添加相关依赖" class="headerlink" title="1.2.2. 创建 Spring Web 项目，添加相关依赖"></a>1.2.2. 创建 Spring Web 项目，添加相关依赖</h4><p>创建时：</p>
<ol>
<li>Web：<ol>
<li>Spring Web</li>
</ol>
</li>
<li>Security：<ol>
<li>Spring Security</li>
</ol>
</li>
<li>SQL<ol>
<li>JDBC API</li>
<li>MyBatis Framework</li>
<li>MySQL Driver</li>
</ol>
</li>
</ol>
<p>创建后：添加 <a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-api">jjwt-api 依赖</a>、<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-impl">jjwt-impl 依赖</a>、<a target="_blank" rel="noopener" href="https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-jackson">jjwt-jackson 依赖</a></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-3-前置步骤"><a href="#1-2-3-前置步骤" class="headerlink" title="1.2.3. 前置步骤"></a>1.2.3. 前置步骤</h4><p>和基于 HttpSession 的 Spring Security 的步骤 1.1.2 ~ 1.1.8 近似一致，只需要在 Spring Security 配置时稍有不同</p>
<hr>
<h4 id="1-2-4-编写-JwtResponse-DTO-类"><a href="#1-2-4-编写-JwtResponse-DTO-类" class="headerlink" title="1.2.4. 编写 JwtResponse DTO 类"></a>1.2.4. 编写 JwtResponse DTO 类</h4><p>JwtResponse 类位于 <code>com.example.securitywithjwt.dto</code> 包下</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtResponse</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> token;<br><br>	<span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-comment">// getter 方法</span><br>	<span class="hljs-comment">// setter 方法</span><br>	<span class="hljs-comment">// equals 方法</span><br>	<span class="hljs-comment">// hashCode 方法</span><br>	<span class="hljs-comment">// toString 方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>用于前后端或服务间传输数据的类，通常称为 DTO 类，属于 POJO 类</li>
</ol>
</blockquote>
<hr>
<h4 id="1-2-5-编写-JWT-生成、提取工具类"><a href="#1-2-5-编写-JWT-生成、提取工具类" class="headerlink" title="1.2.5. 编写 JWT 生成、提取工具类"></a>1.2.5. 编写 JWT 生成、提取工具类</h4><p>JwtUtil 类位于 <code>com.example.securitywithjwt.util</code> 包下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtUtil</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     * JWT 的加密密钥</span><br><span class="hljs-comment">     * --------------------------------------------</span><br><span class="hljs-comment">     * 要求：</span><br><span class="hljs-comment">     * - 不同加密算法，密钥长度要求不同</span><br><span class="hljs-comment">     *      - HMAC-SHA256：32 字节（256 bit）</span><br><span class="hljs-comment">     *      - HMAC-SHA384：48 字节（384 bit）</span><br><span class="hljs-comment">     *      - HMAC-SHA512：64 字节（512 bit）</span><br><span class="hljs-comment">     * - 我们使用的时 HMAC-SHA512 加密算法，即密钥长度至少 64 字节。在 UTF-8 编码下，一个英文占一个字节，也就是说字符串长度至少为 64</span><br><span class="hljs-comment">     * - JJWT 关注的是密钥中包含的真实位数，而不是你包装后的长度。简单来说，你可以将一个 46 字符的字符串进行 Base64 编码，编码后的字节数恰好是 64 字节</span><br><span class="hljs-comment">     * - 在内存中占用 512 bit，看似长度变大了，但 JJWT 仍会报错，因为这只是包装变大了，实际只有 376 位的“真实信息量”</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 注意事项：</span><br><span class="hljs-comment">     * - JWT 签名实际上需要的是一个 二进制的密钥对象，而不是简单的字符串</span><br><span class="hljs-comment">     * - 本方法是根据一个字节数组创建一个 符合 HMAC SHA 算法要求的密钥对象（字节数组必须满足 512 bit，即 64 字节，也就是说字符串长度至少为 64，这样获取到的字符串字节数组就满足 512 bit）</span><br><span class="hljs-comment">     * ============================================</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">SecretKey</span> <span class="hljs-variable constant_">SECRET_KEY</span> = <span class="hljs-title class_">Keys</span>.<span class="hljs-title function_">hmacShaKeyFor</span>(<span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789++&quot;</span>.<span class="hljs-title function_">getBytes</span>(<span class="hljs-title class_">StandardCharsets</span>.<span class="hljs-property">UTF_8</span>));<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final long <span class="hljs-variable constant_">EXPIRATION_TIME</span> = <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span>; <span class="hljs-comment">// Token过期时间，以毫秒为单位，这里是 1 天</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">String</span> <span class="hljs-variable constant_">TOKEN_PREFIX</span> = <span class="hljs-string">&quot;Bearer &quot;</span>; <span class="hljs-comment">// JWT在HTTP请求中的标准前缀，前端发送 JWT 的格式一般为：Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6...</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">String</span> <span class="hljs-variable constant_">HEADER_STRING</span> = <span class="hljs-string">&quot;Authorization&quot;</span>; <span class="hljs-comment">// HTTP请求头中存放 JWT 的字段名</span><br><br>    <span class="hljs-comment">// 生成 JWT</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">generateToken</span>(<span class="hljs-params"><span class="hljs-title class_">CustomerUserDetailsImpl</span> customerUserDetails</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Jwts</span>.<span class="hljs-title function_">builder</span>()<br>                .<span class="hljs-title function_">signWith</span>(<span class="hljs-title class_">SignatureAlgorithm</span>.<span class="hljs-property">HS512</span>, <span class="hljs-variable constant_">SECRET_KEY</span>)<span class="hljs-comment">// Header 部分，使用 HS512 算法</span><br>                .<span class="hljs-title function_">setIssuedAt</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()) <span class="hljs-comment">// Payload 部分，设置签发时间（Registered Claims 部分），JWT 库会自动把它转换成秒级时间戳</span><br>                .<span class="hljs-title function_">setExpiration</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-title class_">System</span>.<span class="hljs-title function_">currentTimeMillis</span>() + <span class="hljs-variable constant_">EXPIRATION_TIME</span>)) <span class="hljs-comment">// Payload 部分，设置过期时间（Registered Claims 部分），JWT 库会自动把它转换成秒级时间戳</span><br>                .<span class="hljs-title function_">claim</span>(<span class="hljs-string">&quot;username&quot;</span>, customerUserDetails.<span class="hljs-title function_">getUsername</span>()) <span class="hljs-comment">// Payload 部分，设置用户的用户名（Private Claims 部分）</span><br>                .<span class="hljs-title function_">compact</span>(); <span class="hljs-comment">// 组合 JWT</span><br>    &#125;<br><br>    <span class="hljs-comment">// 从 JWT 中提取用户名</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUsernameFromToken</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> token</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-title class_">Claims</span> claims = <span class="hljs-title class_">Jwts</span>.<span class="hljs-title function_">parserBuilder</span>()<br>                    .<span class="hljs-title function_">setSigningKey</span>(<span class="hljs-variable constant_">SECRET_KEY</span>)<br>                    .<span class="hljs-title function_">build</span>()<br>                    .<span class="hljs-title function_">parseClaimsJws</span>(token)  <span class="hljs-comment">// 自动检查签名 &amp; 过期时间</span><br>                    .<span class="hljs-title function_">getBody</span>();<br><br>            <span class="hljs-keyword">return</span> claims.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-title class_">String</span>.<span class="hljs-property">class</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (io.<span class="hljs-property">jsonwebtoken</span>.<span class="hljs-property">ExpiredJwtException</span> e) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Token 已过期&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (io.<span class="hljs-property">jsonwebtoken</span>.<span class="hljs-property">SignatureException</span> e) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Token 签名不合法，可能被伪造&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Token 解析失败：&quot;</span> + e.<span class="hljs-title function_">getMessage</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 从 Authorization头中提取 JWT</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">extractBearerToken</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> authorizationHeader</span>) &#123;<br>        <span class="hljs-keyword">if</span> (authorizationHeader != <span class="hljs-literal">null</span> &amp;&amp; authorizationHeader.<span class="hljs-title function_">startsWith</span>(<span class="hljs-variable constant_">TOKEN_PREFIX</span>)) &#123;<br>            <span class="hljs-keyword">return</span> authorizationHeader.<span class="hljs-title function_">substring</span>(<span class="hljs-number">7</span>);  <span class="hljs-comment">// 去除&quot;Bearer &quot;前缀</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-6-编写-JwtRequestFilter-过滤器类"><a href="#1-2-6-编写-JwtRequestFilter-过滤器类" class="headerlink" title="1.2.6. 编写 JwtRequestFilter 过滤器类"></a>1.2.6. 编写 JwtRequestFilter 过滤器类</h4><p>该自定义过滤器负责：每次请求到达时，首先从请求头中的 <code>Authorization</code> 字段提取出 JWT，并校验其签名是否合法以及是否过期，校验通过后，从 JWT 中解析出 <code>username</code>。</p>
<p>随后，通过 <code>username</code> 调用 <code>CustomerUserDetailsImplService</code> 加载完整的 <code>CustomerUserDetailsImpl</code> 用户信息，并将其封装为 <code>Authentication</code> 对象，最终将该对象设置到当前线程的安全上下文中。</p>
<p>如果不能从请求头中提取出 JWT，则直接跳过该过滤器。</p>
<p>JwtRequestFilter 类位于 <code>com.example.securitywithjwt.filter</code> 包下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Component</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtRequestFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">UserDetailsService</span> userDetailsService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void doFilterInternal(<span class="hljs-type">HttpServletRequest</span> request,<br>                                    <span class="hljs-type">HttpServletResponse</span> response,<br>                                    <span class="hljs-type">FilterChain</span> filterChain)<br>            <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;<br><br>        <span class="hljs-comment">// 从请求头中提取 JWT</span><br>        <span class="hljs-type">String</span> token = <span class="hljs-type">JwtUtil</span>.extractBearerToken(request.getHeader(<span class="hljs-string">&quot;Authorization&quot;</span>));<br><br>        <span class="hljs-comment">// 如果 token 存在，则进行认证</span><br>        <span class="hljs-keyword">if</span> (token != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 从 token 中提取 username，验证已在 getUsernameFromToken 中完成</span><br>            <span class="hljs-type">String</span> username = <span class="hljs-type">JwtUtil</span>.getUsernameFromToken(token);<br>            <span class="hljs-comment">// 如果 username 有效且当前上下文未认证</span><br>            <span class="hljs-keyword">if</span> (username != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-type">SecurityContextHolder</span>.getContext().getAuthentication() == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 加载用户信息</span><br>                    <span class="hljs-type">UserDetails</span> userDetails = userDetailsService.loadUserByUsername(username);<br>                    <span class="hljs-comment">// 创建认证对象</span><br>                    <span class="hljs-type">UsernamePasswordAuthenticationToken</span> auth =<br>                            <span class="hljs-keyword">new</span> <span class="hljs-type">UsernamePasswordAuthenticationToken</span>(<br>                                    userDetails, <span class="hljs-literal">null</span>, userDetails.getAuthorities()<br>                            );<br>                    <span class="hljs-comment">// 设置请求详情</span><br>                    auth.setDetails(<span class="hljs-keyword">new</span> <span class="hljs-type">WebAuthenticationDetailsSource</span>().buildDetails(request));<br>                    <span class="hljs-comment">// 将认证信息存入安全上下文</span><br>                    <span class="hljs-type">SecurityContextHolder</span>.getContext().setAuthentication(auth);<br>                &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">Exception</span> e) &#123;<br>                    <span class="hljs-comment">// 加载用户信息失败时记录日志，不影响后续流程</span><br>                    logger.error(<span class="hljs-string">&quot;Failed to load user details for username: &quot;</span> + username, e);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 继续执行过滤器链</span><br>        filterChain.doFilter(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-7-添加-JwtRequestFilter-过滤器到-Security-过滤器链"><a href="#1-2-7-添加-JwtRequestFilter-过滤器到-Security-过滤器链" class="headerlink" title="1.2.7. 添加 JwtRequestFilter 过滤器到 Security 过滤器链"></a>1.2.7. 添加 JwtRequestFilter 过滤器到 Security 过滤器链</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@EnableWebSecurity</span><br><span class="hljs-variable">@EnableMethodSecurity</span><br>public class SecurityConfig &#123;<br><br>    <span class="hljs-variable">@Autowired</span><br>	private JwtRequestFilter jwtRequestFilter;<br><br>    <span class="hljs-variable">@Bean</span><br>    public SecurityFilterChain <span class="hljs-built_in">securityFilterChain</span>(HttpSecurity http) throws Exception &#123;<br>        <span class="hljs-selector-tag">http</span><span class="hljs-selector-class">.addFilterBefore</span>(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class); <br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-8-实现-注册-API、登录-API、授权-API、测试-API、注销-API"><a href="#1-2-8-实现-注册-API、登录-API、授权-API、测试-API、注销-API" class="headerlink" title="1.2.8. 实现 注册 API、登录 API、授权 API、测试 API、注销 API"></a>1.2.8. 实现 注册 API、登录 API、授权 API、测试 API、注销 API</h4><p>AuthController 类位于 <code>com.example.securitywithjwt.controller</code> 包下</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">AuthenticationManager</span> authenticationManager;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">PasswordEncoder</span> passwordEncoder;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserMapper</span> userMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserRoleMapper</span> userRoleMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">TestService</span> testService;<br><br>    <span class="hljs-comment">// 注册方法</span><br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/public/signup&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">signUp</span>(<span class="hljs-params"><span class="hljs-meta">@RequestBody</span> <span class="hljs-title class_">User</span> user</span>) &#123;<br>        <span class="hljs-title class_">String</span> encodePassword = passwordEncoder.<span class="hljs-title function_">encode</span>(user.<span class="hljs-title function_">getPassword</span>());<br><br>        int i = userMapper.<span class="hljs-title function_">insertUser</span>(user.<span class="hljs-title function_">getUsername</span>(), encodePassword, user.<span class="hljs-title function_">getEmail</span>(), user.<span class="hljs-title function_">getPhoneNumber</span>());<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;服务器繁忙，请稍后再试&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;用户注册成功&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 登录方法</span><br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/public/login&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">logIn</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">&quot;username&quot;</span>) <span class="hljs-title class_">String</span> username,</span><br><span class="hljs-params">                        <span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">&quot;password&quot;</span>) <span class="hljs-title class_">String</span> password,</span><br><span class="hljs-params">                        <span class="hljs-title class_">HttpServletRequest</span> request,</span><br><span class="hljs-params">                        <span class="hljs-title class_">HttpServletResponse</span> response</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将 username 和 password 封装成 UsernamePasswordAuthenticationToken</span><br>            <span class="hljs-title class_">UsernamePasswordAuthenticationToken</span> token =<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">UsernamePasswordAuthenticationToken</span>(username, password);<br><br>            <span class="hljs-comment">// 传递给 AuthenticationManager 进行认证</span><br>            <span class="hljs-title class_">Authentication</span> auth = authenticationManager.<span class="hljs-title function_">authenticate</span>(token);<br><br>            <span class="hljs-comment">// 将 Authentication 保存到当前线程的 SecurityContext</span><br>            <span class="hljs-title class_">SecurityContextHolder</span>.<span class="hljs-title function_">getContext</span>().<span class="hljs-title function_">setAuthentication</span>(auth);<br><br>            <span class="hljs-comment">// 获取当前请求中的 CSRF Token（此 token 是 Spring Security 自动生成并放入 request 中的）</span><br>            <span class="hljs-title class_">CsrfToken</span> csrfToken = (<span class="hljs-title class_">CsrfToken</span>) request.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-title class_">CsrfToken</span>.<span class="hljs-property">class</span>.<span class="hljs-title function_">getName</span>());<br><br>            <span class="hljs-title class_">String</span> jwtToken = <span class="hljs-title class_">JwtUtil</span>.<span class="hljs-title function_">generateToken</span>(<span class="hljs-title class_">AuthenticationUtils</span>.<span class="hljs-title function_">getCustomerUserDetailsImpl</span>());<br><br>            <span class="hljs-comment">// 将 token 返回给前端，常见做法是放入响应头，也可以放入响应体</span><br>            response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;X-CSRF-TOKEN&quot;</span>, csrfToken.<span class="hljs-title function_">getToken</span>());<br>            response.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&quot;JWT-TOKEN&quot;</span>, jwtToken);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录成功，欢迎用户：&quot;</span> + auth.<span class="hljs-title function_">getName</span>();<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">AuthenticationException</span> e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;登录失败，用户名或密码错误&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 授权方法</span><br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/grantaccess&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">grantAccess</span>(<span class="hljs-params"><span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">&quot;userid&quot;</span>) int userid,</span><br><span class="hljs-params">                              <span class="hljs-meta">@RequestParam</span>(<span class="hljs-string">&quot;roleid&quot;</span>) int roleid</span>) &#123;<br>        int i = userRoleMapper.<span class="hljs-title function_">insertUserRole</span>(userid, roleid);<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;服务器繁忙，请稍后再试&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功将 &quot;</span> + roleid + <span class="hljs-string">&quot; 授权给 &quot;</span> + userid;<br>    &#125;<br><br>    <span class="hljs-comment">// 测试方法</span><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/test&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;正在执行只有 test:test:test 权限才能执行的 Service 方法&quot;</span>);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;现在的 Authentication 信息如下：&quot;</span>);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-title class_">AuthenticationUtils</span>.<span class="hljs-title function_">getAuthentication</span>());<br>        <span class="hljs-title class_">String</span> testString = testService.<span class="hljs-title function_">test</span>();<br>        <span class="hljs-keyword">return</span> testString;<br>    &#125;<br><br>    <span class="hljs-comment">// 注销方法</span><br>    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">&quot;/public/logOut&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">logout</span>(<span class="hljs-params"><span class="hljs-title class_">HttpServletRequest</span> request</span>) &#123;<br>        <span class="hljs-comment">// 注销方法我们可以使用黑名单的方式，但是最简单的方式是，前端直接把 JWT 丢弃。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>配置了密码加密器后，AuthenticationManager 会将用户提交的密码加密并与数据库中查询出的密码进行匹配。如果数据库中仍是明文密码，将无法通过校验，返回“登录失败，用户名或密码错误”。</li>
<li>为了实现这些 API，我还另外书写了 UserRole.java、UserRoleMapper.java、UserRoleMapper.xml、TestService.java，并补充了 UserMapper.java、UserMapper.xml 详细请下载源码查看：summer&#x2F;SecurityWithHttpSession</li>
</ol>
</blockquote>
<hr>
<h2 id="2-业务处理"><a href="#2-业务处理" class="headerlink" title="2. 业务处理"></a>2. 业务处理</h2><h3 id="2-1-Spring-Security-集成-OAuth2"><a href="#2-1-Spring-Security-集成-OAuth2" class="headerlink" title="2.1. Spring Security 集成 OAuth2"></a>2.1. Spring Security 集成 OAuth2</h3><p>详见笔记：OAuth 协议</p>
<hr>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  
    <span>></span>
    
  <a href="/categories/Java/Spring-%E7%94%9F%E6%80%81/" class="category-chain-item">Spring 生态</a>
  
  
    <span>></span>
    
  <a href="/categories/Java/Spring-%E7%94%9F%E6%80%81/Spring-Security/" class="category-chain-item">Spring Security</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>笔记：Spring Security</div>
      <div>https://wangjia5289.github.io/2025/05/18/笔记：Spring Security/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>霸天</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>May 18, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/" title="笔记：JUC">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">笔记：JUC</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/17/%E7%AC%94%E8%AE%B0%EF%BC%9ARedis%20%E5%9F%BA%E7%A1%80/" title="笔记：Redis 基础">
                        <span class="hidden-mobile">笔记：Redis 基础</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'en'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/en.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"display":{"superSample":2,"width":200,"height":350,"position":"left","hOffset":40,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":1,"opacityOnHover":0.5},"log":false});</script></body>
</html>
