

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/ico.png">
  <link rel="icon" href="/img/ico.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#373737">
  <meta name="author" content="霸天">
  <meta name="keywords" content="">
  
    <meta name="description" content="1. 导图  2. 查看线程2.1. Windows1. 任务管理器快捷键为：Ctrl + Shift + Esc 2. 命令行工具 12345678910&#x2F;&#x2F; 1. 查看进程tasklist&quot;&quot;&quot;1. 注意事项	1. 可以使用 tasklist | findstr &lt;进程名&gt; 来筛选特定进程&quot;&quot;&quot;&#x2F;&#x2F; 2. 杀死进程task">
<meta property="og:type" content="article">
<meta property="og:title" content="笔记：JUC">
<meta property="og:url" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/index.html">
<meta property="og:site_name" content="夜阑卧听风吹雨,一枝梨花压心头">
<meta property="og:description" content="1. 导图  2. 查看线程2.1. Windows1. 任务管理器快捷键为：Ctrl + Shift + Esc 2. 命令行工具 12345678910&#x2F;&#x2F; 1. 查看进程tasklist&quot;&quot;&quot;1. 注意事项	1. 可以使用 tasklist | findstr &lt;进程名&gt; 来筛选特定进程&quot;&quot;&quot;&#x2F;&#x2F; 2. 杀死进程task">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://wangjia5289.github.io/source/_posts/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/Map%EF%BC%9AJUC.xmind">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250717222336285.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250717201013757.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250718153733803.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250718231947171.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250718232007146.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719085830451.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719102443800.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719100014731.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719100114713.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719100159695.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719100555573.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719101118338.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719101521799.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250720093607520.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719183232957.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719223150888.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719223516927.png">
<meta property="og:image" content="https://wangjia5289.github.io/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719223757282.png">
<meta property="article:published_time" content="2025-05-17T16:00:00.000Z">
<meta property="article:modified_time" content="2025-07-20T06:44:24.742Z">
<meta property="article:author" content="Ba Yuan">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://wangjia5289.github.io/source/_posts/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/Map%EF%BC%9AJUC.xmind">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>笔记：JUC - 夜阑卧听风吹雨,一枝梨花压心头</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"wangjia5289.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="笔记：JUC"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-05-18 00:00" pubdate>
          May 18, 2025 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          112 mins
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        

      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">笔记：JUC</h1>
            
              <p id="updated-time" class="note note-info" style="display: none">
                
                  
                    Last updated on 2025-07-20T14:44:24+08:00
                  
                  

                
              </p>
            
            
              <div class="markdown-body">
                
                <h2 id="1-导图"><a href="#1-导图" class="headerlink" title="1. 导图"></a>1. 导图</h2><p><img src="/source/_posts/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/Map%EF%BC%9AJUC.xmind" srcset="/img/loading.gif" lazyload></p>
<hr>
<h2 id="2-查看线程"><a href="#2-查看线程" class="headerlink" title="2. 查看线程"></a>2. 查看线程</h2><h3 id="2-1-Windows"><a href="#2-1-Windows" class="headerlink" title="2.1. Windows"></a>2.1. Windows</h3><p><font color="#92d050">1. 任务管理器</font><br>快捷键为：Ctrl + Shift + Esc</p>
<p><font color="#92d050">2. 命令行工具</font></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 查看进程<br>tasklist<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1. 注意事项</span><br><span class="hljs-string">	1. 可以使用 tasklist | findstr &lt;进程名&gt; 来筛选特定进程</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 杀死进程<br>taskkill <span class="hljs-regexp">/F /</span>PID &lt;进程 ID&gt;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-2-Linux"><a href="#2-2-Linux" class="headerlink" title="2.2. Linux"></a>2.2. Linux</h3><p><font color="#92d050">1. ps 命令</font></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 1. 查看所有进程</span><br>ps -ef<br><br><br><span class="hljs-comment">// 2. 查看某个进程（PID）下的所有线程</span><br>ps -fT -<span class="hljs-selector-tag">p</span> &lt;进程 ID&gt;<br></code></pre></td></tr></table></figure>


<p><font color="#92d050">2. top 命令</font></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 实时查看进程资源占用情况<br>top<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1. 注意事项：</span><br><span class="hljs-string">	1. 按下大写 H 可切换是否显示线程视图</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 实时查看某个进程（PID）下的线程资源占用<br>top -H -p &lt;进程 ID&gt;<br></code></pre></td></tr></table></figure>


<p><font color="#92d050">3. kill 命令</font></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 请求进程优雅退出（发送 SIGTERM）<br>kill &lt;进程 ID&gt;<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1. 注意事项：</span><br><span class="hljs-string">	1. 进程可捕获此信号，用于执行资源释放、状态保存等清理操作</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 强制终止进程（发送 SIGKILL）<br>kill -<span class="hljs-number">9</span> &lt;进程ID&gt;<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">1. 注意事项：</span><br><span class="hljs-string">	1. 用于强制终止卡死、无法响应的进程，不会触发清理逻辑</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="2-3-Java-专属命令"><a href="#2-3-Java-专属命令" class="headerlink" title="2.3. Java 专属命令"></a>2.3. Java 专属命令</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// 1. 查看所有 Java 进程</span><br>jps<br><br><br><span class="hljs-comment">// 2. 查看某个 Java 进程（PID）下的所有线程</span><br>jstack &lt;Java 进程 ID&gt;<br></code></pre></td></tr></table></figure>


<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>Windows 系统中的 <code>jconsole</code> 是一个图形化工具，可用于查看 Java 进程中各线程的运行状态与资源使用情况</li>
<li>该工具默认只能查看本地 Windows 机器上的 Java 进程线程。如果要远程监控，需要用以下命令启动目标机器上的 jar 包：</li>
</ol>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java -Djava<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.hostname=<span class="hljs-string">&#x27;&lt;ip 地址&gt;&#x27;</span> -Dcom<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.jmxremote</span> -Dcom<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.jmxremote</span>.port=<span class="hljs-string">&#x27;&lt;连接端口&gt;&#x27;</span> -Dcom<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.jmxremote</span>.ssl=false -Dcom<span class="hljs-selector-class">.sun</span><span class="hljs-selector-class">.management</span><span class="hljs-selector-class">.jmxremote</span>.authenticate=false -jar yourapp.jar<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="3-创建线程"><a href="#3-创建线程" class="headerlink" title="3. 创建线程"></a>3. 创建线程</h2><h3 id="3-1-直接使用-Thread"><a href="#3-1-直接使用-Thread" class="headerlink" title="3.1. 直接使用 Thread"></a>3.1. 直接使用 Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建线程对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;myThread&quot;</span>) &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// 本线程要执行的任务</span><br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">// 2. 启动线程</span><br>myThread.start();<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-使用-Runnable-Thread"><a href="#3-2-使用-Runnable-Thread" class="headerlink" title="3.2. 使用 Runnable + Thread"></a>3.2. 使用 Runnable + Thread</h3><p>直接使用 <code>Thread</code> 相当于将线程控制与具体任务耦合在一起，为了具有更好的灵活性，也为了更容易与线程池等高级并发 API 配合使用，我们可以使用 <code>Runnable</code> 实现了线程与任务的分离。</p>
<p><code>Runnable</code> 是一个接口，其源码如下所示：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们可以通过如下方式创建一个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建 Runnable 接口对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">// 本 Runnable 要执行的任务</span><br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">// 2. 创建线程对象，传入 Runnable 接口对象。线程将执行 Runnable 中指定的 run 方法</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;myThread&quot;</span>);<br><br><span class="hljs-comment">// 3. 启动线程</span><br>myThread.start();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>在 Java 中，只包含一个抽象方法的接口可以加上 <code>@FunctionalInterface</code> 注解，表示该接口是一个函数式接口，从而可以使用 lambda 表达式进行简洁书写（只有一个抽象方法，但还可能存在几个 default 方法）</li>
<li>如果 lambda 表达式中有多条语句，必须使用花括号 <code>&#123;&#125;</code> 包裹；如果只有一条语句，则可以省略花括号。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. Runnable 源码</span><br><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-comment">// 2. lambda 表达式创建 Runnable</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>	<span class="hljs-comment">// 本 Runnable 要执行的任务</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<blockquote>
<ol start="3">
<li>Runnable 是一个接口，而创建 Runnable 接口通常有三种常见玩法：</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 直接 new 出接口对象</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;运行中&quot;</span>);<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">// 2. 向上转型 new 出接口对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;运行中&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><br><br><span class="hljs-comment">// 3. new 出实现类（MyRunnable）类型的对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;运行中&quot;</span>);  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-3-使用-FutureTask-Thread"><a href="#3-3-使用-FutureTask-Thread" class="headerlink" title="3.3. 使用 FutureTask + Thread"></a>3.3. 使用 FutureTask + Thread</h3><h4 id="3-3-1-Runnable-的缺陷"><a href="#3-3-1-Runnable-的缺陷" class="headerlink" title="3.3.1. Runnable 的缺陷"></a>3.3.1. Runnable 的缺陷</h4><p>无论是使用 Runnable + Thread，还是直接使用 Thread，我们都会发现只能执行无返回值的方法。也就是说，方法执行完成后无法获取返回值，而有时我们确实需要返回值来进行错误处理。</p>
<p>除此之外，我们也发现，使用 Runnable 时也无法抛出受检异常（checked Exception）。</p>
<hr>
<h4 id="3-3-2-Callable-的引入"><a href="#3-3-2-Callable-的引入" class="headerlink" title="3.3.2. Callable 的引入"></a>3.3.2. Callable 的引入</h4><p>Callable 和 Runnable 类似，都是用来定义任务的接口。不同的是，Callable 定义了带返回值且可抛异常的 <code>V call()</code> 方法。</p>
<p>但需要注意的是，Thread 构造方法只能接收 Runnable 类型的对象，因此 Callable 不能像 Runnable 那样直接传给 Thread 使用。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="3-4-FutureTask-Thread-的使用"><a href="#3-4-FutureTask-Thread-的使用" class="headerlink" title="3.4. FutureTask + Thread 的使用"></a>3.4. FutureTask + Thread 的使用</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">// 1. 创建 Callable 接口对象</span><br>Callable&lt;Integer&gt; <span class="hljs-keyword">task</span> = <span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<br>	@Override<br>	<span class="hljs-keyword">public</span> Integer <span class="hljs-keyword">call</span>() <span class="hljs-keyword">throws</span> Exception &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">// 2. 创建 FutureTask 对象，传入 Callable 接口对象。</span><br>FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">task</span>);<br><br><span class="hljs-comment">// 3. 创建线程对象，传入 FutureTask 对象。线程将指向 Callable 中指定的 call 方法，并能调用 FutureTask 的方法进行相关操作</span><br>Thread myThread = <span class="hljs-keyword">new</span> Thread(futureTask, <span class="hljs-string">&quot;myThread&quot;</span>);<br><br><span class="hljs-comment">// 4. 启动线程</span><br>myThread.start();<br><br><span class="hljs-comment">// 5. 调用 FutureTask  相关方法</span><br><span class="hljs-keyword">try</span> &#123;<br>    Integer result = futureTask.get();  <span class="hljs-comment">// 阻塞等待任务执行完成，获取返回值</span><br>    System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;任务返回结果: &quot;</span> + result);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>创建 FutureTask 对象时，可直接使用 Lambda 表达式，无需单独创建 Callable 接口对象</li>
</ol>
</blockquote>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;<span class="hljs-function"><span class="hljs-params">(() -&gt; <span class="hljs-number">1</span> + <span class="hljs-number">2</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">Thread</span> <span class="hljs-title">myThread</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(futureTask, <span class="hljs-string">&quot;myThread&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">myThread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure>

<hr>
<h2 id="4-线程的状态"><a href="#4-线程的状态" class="headerlink" title="4. 线程的状态"></a>4. 线程的状态</h2><h3 id="4-1-操作系统层面"><a href="#4-1-操作系统层面" class="headerlink" title="4.1. 操作系统层面"></a>4.1. 操作系统层面</h3><p><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250717222336285.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h3 id="4-2-Java-层面"><a href="#4-2-Java-层面" class="headerlink" title="4.2. Java 层面"></a>4.2. Java 层面</h3><p><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250717201013757.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h2 id="5-JUC-常用方法"><a href="#5-JUC-常用方法" class="headerlink" title="5. JUC 常用方法"></a>5. JUC 常用方法</h2><h3 id="5-1-常用方法一览表"><a href="#5-1-常用方法一览表" class="headerlink" title="5.1. 常用方法一览表"></a>5.1. 常用方法一览表</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>Thread static 方法</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Thread.sleep(long)</td>
<td>static</td>
<td>让当前执行的线程休眠 n 毫秒（从运行状态进入 Timed Waiting 状态），休眠时会让出 cpu 的时间片给其它线程</td>
<td>1. 其他线程可以通过 <code>interrupt</code> 方法打断当前正在睡眠的线程，此时 <code>sleep</code> 方法会抛出 <code>InterruptedException</code>。如果你未捕获并处理该异常，线程可能会直接终止；<br><br>2. 如果线程在睡眠结束或被中断（并正确处理了异常），将会从 <code>TIMED_WAITING</code> 状态被唤醒，转入就绪状态，等待 CPU 分配时间片继续执行。<br><br>3. 建议使用 TimeUnit 的 sleep 代替 Thread 的 sleep，两者功能相同，但前者可读性更强，单位更清晰。<br><br>4. 以 毫秒 为单位，1000 毫秒是 1 秒</td>
</tr>
<tr>
<td>Thread.yield()</td>
<td>static</td>
<td>提示线程调度器让出当前执行的线程对 CPU 的使用，线程从运行状态进入就绪状态</td>
<td>1. 主要是为了测试和调试<br><br>2. yield 方法仅是建议性提示，是否生效取决于具体的调度策略；<br><br>3. 与 <code>sleep()</code> 方法的区别在于：<code>yield()</code> 让出时间片后，线程会处于就绪状态，如果没有其他可运行的线程，当前线程仍有可能被继续调度执行；而 <code>sleep()</code> 会使线程进入<code>TIMED_WAITING</code>，不能随即就被调度</td>
</tr>
<tr>
<td>Thread 实例方法</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>xxThread.start()</td>
<td></td>
<td>启动一个新线程，在新的线程运行 run 方法中的代码</td>
<td>1. start 方法只是让线程从初始状态进入就绪状态，里面代码不一定立刻运行（需要CPU 将时间片分配给它）<br><br>2. 每个线程对象的 start 方法只能调用一次（即使线程已终止），如果调用多次会出现 IllegalThreadStateException<br><br>3.<code>static</code> 方法是通过类名调用，如 <code>Thread.xxx</code>；非 <code>static</code> 方法是通过实例对象调用，如 <code>myThread.xxx</code>。</td>
</tr>
<tr>
<td>xxThread.setPriority(int)</td>
<td></td>
<td>修改某线程的优先级</td>
<td>1. Java 中规定线程优先级为 1~10 之间的整数，数值越大，表示该线程被 CPU 调度的概率越高；<br><br>2. 该优先级仅是建议性提示，是否生效取决于具体的调度策略；<br><br>3. 当 CPU 忙碌时，高优先级线程通常会获得更多时间片；但在 CPU 空闲时，优先级对调度几乎无影响。</td>
</tr>
<tr>
<td>xxThread.join()</td>
<td></td>
<td>等待某线程运行结束</td>
<td></td>
</tr>
<tr>
<td>xxThread.join(long)</td>
<td></td>
<td>等待某线程运行结束，最多等待 n 毫秒</td>
<td>1. 超时后，代码不再等待，继续向下执行；<br><br>2. 以 毫秒 为单位，1000 毫秒是 1 秒</td>
</tr>
<tr>
<td>xxThread.setDaemon(boolean)</td>
<td></td>
<td>将某线程（用户线程）设置为守护线程</td>
<td>1. 主线程和我们创建的线程默认都是用户线程。很多人误以为“主线程一结束，JVM 就会退出”，但实际上并非如此，即使主线程结束，只要还有其他用户线程存活，JVM 就不会退出。<br><br>2. 而守护线程的行为则不同，当所有非守护线程（即用户线程）都结束后，JVM 会自动退出，无需等待守护线程执行完毕。<br><br>3. 守护线程常用于后台服务，例如垃圾回收、心跳监控、日志清理等任务</td>
</tr>
<tr>
<td>Object 实例方法</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="5-2-Thread-static-方法"><a href="#5-2-Thread-static-方法" class="headerlink" title="5.2. Thread static 方法"></a>5.2. Thread static 方法</h3><h4 id="5-2-1-sleep-long-方法"><a href="#5-2-1-sleep-long-方法" class="headerlink" title="5.2.1. sleep(long) 方法"></a>5.2.1. sleep(long) 方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep(long)</td>
<td>static</td>
<td>让当前执行的线程休眠 n 毫秒（从运行状态进入 Timed Waiting 状态），休眠时会让出 cpu 的时间片给其它线程</td>
<td>1. 其他线程可以通过 <code>interrupt</code> 方法打断当前正在睡眠的线程，此时 <code>sleep</code> 方法会抛出 <code>InterruptedException</code>。如果你未捕获并处理该异常，线程可能会直接终止；<br><br>2. 如果线程在睡眠结束或被中断（并正确处理了异常），将会从 <code>TIMED_WAITING</code> 状态被唤醒，转入就绪状态，等待 CPU 分配时间片继续执行。<br><br>3. 建议使用 TimeUnit 的 sleep 代替 Thread 的 sleep，两者功能相同，但前者可读性更强，单位更清晰。<br><br>4. 以 毫秒 为单位，1000 毫秒是 1 秒</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        Callable&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <br>                <span class="hljs-comment">// 执行本方法的线程进行 sleep</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">50000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;;<br><br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(task);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask, <span class="hljs-string">&quot;myThread&quot;</span>);<br><br>        myThread.start();<br><br>        <span class="hljs-comment">// Main 线程 sleep</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <br>        myThread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>使用 TimeUnit：</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        Callable&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <br>                <span class="hljs-comment">// 执行本方法的线程 sleep</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.HOURS.sleep(<span class="hljs-number">5</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;;<br><br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(task);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask, <span class="hljs-string">&quot;myThread&quot;</span>);<br><br>        myThread.start();<br><br>        <span class="hljs-comment">// Main 线程 sleep</span><br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">5000</span>);<br><br>        myThread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="5-2-2-yield-方法"><a href="#5-2-2-yield-方法" class="headerlink" title="5.2.2. yield() 方法"></a>5.2.2. yield() 方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.yield()</td>
<td>static</td>
<td>提示线程调度器让出当前执行的线程对 CPU 的使用，线程从运行状态进入就绪状态</td>
<td>1. 主要是为了测试和调试<br><br>2. yield 方法仅是建议性提示，是否生效取决于具体的调度策略；<br><br>3. 与 <code>sleep()</code> 方法的区别在于：<code>yield()</code> 让出时间片后，线程会处于就绪状态，如果没有其他可运行的线程，当前线程仍有可能被继续调度执行；而 <code>sleep()</code> 会使线程进入<code>TIMED_WAITING</code>，不能随即就被调度</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                Thread.<span class="hljs-keyword">yield</span>();<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;-----&gt;1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;       -----&gt;2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable1, <span class="hljs-string">&quot;myThread1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable2, <span class="hljs-string">&quot;myThread2&quot;</span>);<br>        <br>        myThread1.start();<br>        <br>        myThread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>该代码在多核处理器上效果可能不明显，但在单核环境中其调度行为将更为明显</li>
</ol>
</blockquote>
<hr>
<h3 id="5-3-Thread-实例方法"><a href="#5-3-Thread-实例方法" class="headerlink" title="5.3. Thread 实例方法"></a>5.3. Thread 实例方法</h3><h4 id="5-3-1-start-方法"><a href="#5-3-1-start-方法" class="headerlink" title="5.3.1. start() 方法"></a>5.3.1. start() 方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>xxThread.start()</td>
<td></td>
<td>启动一个新线程，在新的线程运行 run 方法中的代码</td>
<td>1. start 方法只是让线程从初始状态进入就绪状态，里面代码不一定立刻运行（需要CPU 将时间片分配给它）<br><br>2. 每个线程对象的 start 方法只能调用一次（即使线程已终止），如果调用多次会出现 IllegalThreadStateException<br><br>3.<code>static</code> 方法是通过类名调用，如 <code>Thread.xxx</code>；非 <code>static</code> 方法是通过实例对象调用，如 <code>myThread.xxx</code>。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <br>        Callable&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;;<br>        <br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(task);<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask, <span class="hljs-string">&quot;myThread&quot;</span>);<br>        <br>        myThread.start();<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="5-3-2-setPriority-int-方法"><a href="#5-3-2-setPriority-int-方法" class="headerlink" title="5.3.2. setPriority(int) 方法"></a>5.3.2. setPriority(int) 方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>xxThread.setPriority(int)</td>
<td></td>
<td>修改某线程的优先级</td>
<td>1. Java 中规定线程优先级为 1~10 之间的整数，数值越大，表示该线程被 CPU 调度的概率越高；<br><br>2. 该优先级仅是建议性提示，是否生效取决于具体的调度策略；<br><br>3. 当 CPU 忙碌时，高优先级线程通常会获得更多时间片；但在 CPU 空闲时，优先级对调度几乎无影响。</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;-----&gt;1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;       -----&gt;2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable1, <span class="hljs-string">&quot;myThread1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable2, <span class="hljs-string">&quot;myThread2&quot;</span>);<br>        <br>        <span class="hljs-comment">// 设置线程优先级</span><br>        myThread1.setPriority(Thread.MAX_PRIORITY);<br><br>        myThread1.start();<br>        <br>        myThread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="5-3-3-join-、join-long-方法"><a href="#5-3-3-join-、join-long-方法" class="headerlink" title="5.3.3. join()、join(long) 方法"></a>5.3.3. join()、join(long) 方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>xxThread.join()</td>
<td></td>
<td>等待某线程运行结束</td>
<td></td>
</tr>
<tr>
<td>xxThread.join(long)</td>
<td></td>
<td>等待某线程运行结束，最多等待 n 毫秒</td>
<td>1. 超时后，代码不再等待，继续向下执行；<br><br>2. 以 毫秒 为单位，1000 毫秒是 1 秒</td>
</tr>
</tbody></table>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> repertoryNumber  = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>) throws ExecutionException, InterruptedException</span> &#123;<br><br>        Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            @Override<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 模拟从 MySQL 中读取数据，假设独到的是 1500</span><br>                    TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);<br>                    repertoryNumber = <span class="hljs-number">1500</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        Thread myThread = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">&quot;myThread&quot;</span>);<br><br>        myThread.start();<br><br>        myThread.<span class="hljs-keyword">join</span>();<br><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;从数据库中读取的数据为：&quot;</span>+ repertoryNumber);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="5-3-4-setDaemon-boolean"><a href="#5-3-4-setDaemon-boolean" class="headerlink" title="5.3.4. setDaemon(boolean)"></a>5.3.4. setDaemon(boolean)</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>xxThread.setDaemon(boolean)</td>
<td></td>
<td>将某线程（用户线程）设置为守护线程</td>
<td>1. 主线程和我们创建的线程默认都是用户线程。很多人误以为“主线程一结束，JVM 就会退出”，但实际上并非如此，即使主线程结束，只要还有其他用户线程存活，JVM 就不会退出。<br><br>2. 而守护线程的行为则不同，当所有非守护线程（即用户线程）都结束后，JVM 会自动退出，无需等待守护线程执行完毕。<br><br>3. 守护线程常用于后台服务，例如垃圾回收、心跳监控、日志清理等任务</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">repertoryNumber</span>  <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;  <br>  <br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;  <br>                    <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted())&#123;  <br>                        <span class="hljs-keyword">break</span>;  <br>                    &#125;  <br>                &#125;  <br>            &#125;  <br>        &#125;;  <br>  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable, <span class="hljs-string">&quot;myThread&quot;</span>);  <br>  <br>        <span class="hljs-comment">// 设置为守护线程  </span><br>        myThread.setDaemon(<span class="hljs-literal">true</span>);  <br>  <br>        myThread.start();  <br>  <br>        System.out.println(<span class="hljs-string">&quot;从数据库中读取的数据为：&quot;</span>+ repertoryNumber);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>上面的代码如果没有设置为守护线程，即使 <code>main</code> 方法执行完毕，JVM 仍不会停止运行。</li>
</ol>
</blockquote>
<hr>
<table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>join()</td>
<td></td>
<td>等待线程运行结束</td>
<td></td>
</tr>
<tr>
<td>join(long n)</td>
<td></td>
<td>等待线程运行结束，最多等待 n 毫秒</td>
<td></td>
</tr>
<tr>
<td>start()</td>
<td></td>
<td>启动一个新线程，在新的线程运行 run 方法中的代码</td>
<td>1. start 方法只是让线程从初始状态进入就绪状态，里面代码不一定立刻运行（需要CPU 将时间片分配给它）<br><br>2. 每个线程对象的 start 方法只能调用一次（即使线程已终止），如果调用多次会出现 IllegalThreadStateException</td>
</tr>
<tr>
<td>sleep(long n)</td>
<td>static</td>
<td>让当前执行的线程休眠n 毫秒（从 Running 进入 Timed Waiting），休眠时让出 cpu 的时间片给其它线程</td>
<td></td>
</tr>
<tr>
<td>yield()</td>
<td>static</td>
<td>提示线程调度器让出当前线程对CPU的使用</td>
<td>主要是为了测试和调试</td>
</tr>
<tr>
<td>setPriority(int)</td>
<td></td>
<td>修改线程优先级</td>
<td>java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率</td>
</tr>
<tr>
<td>getId()</td>
<td></td>
<td>获取线程长整型的 id</td>
<td>id 唯一</td>
</tr>
<tr>
<td>getName()</td>
<td></td>
<td>获取线程名</td>
<td></td>
</tr>
<tr>
<td>setName(String)</td>
<td></td>
<td>修改线程名</td>
<td></td>
</tr>
<tr>
<td>getPriority()</td>
<td></td>
<td>获取线程优先级</td>
<td></td>
</tr>
<tr>
<td>getState()</td>
<td></td>
<td>获取线程状态</td>
<td>Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</td>
</tr>
<tr>
<td>isInterrupted()</td>
<td></td>
<td>判断是否被打断</td>
<td>不会清除打断标记</td>
</tr>
<tr>
<td>isAlive()</td>
<td></td>
<td>线程是否存活（还没有运行完毕）</td>
<td></td>
</tr>
<tr>
<td>interrupt()</td>
<td></td>
<td>打断线程</td>
<td>如果被打断线程正在 sleep, wait, join 会导致被打断的线程抛出 InterruptedException，并清除打断标记；如果打断的正在运行的线程，则会设置打断标记；park 的线程被打断，也会设置打断标记</td>
</tr>
<tr>
<td>interrupted()</td>
<td>static</td>
<td>判断当前线程是否被打断</td>
<td>会清除打断标记</td>
</tr>
<tr>
<td>currentThread()</td>
<td>static</td>
<td>获取当前正在执行的线程</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="5-4-Object-实例方法"><a href="#5-4-Object-实例方法" class="headerlink" title="5.4. Object 实例方法"></a>5.4. Object 实例方法</h3><h4 id="5-4-1-wait-方法"><a href="#5-4-1-wait-方法" class="headerlink" title="5.4.1. wait() 方法"></a>5.4.1. wait() 方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>Object.wait()</td>
<td></td>
<td>使当前持有该对象锁的线程进入该对象监视器（Monitor）中的 WaitSet 中等待，同时释放对象锁和 CPU 执行权</td>
<td>1. 与 <code>sleep()</code> 的区别是，<code>sleep()</code> 使线程进入 TIMED_WAITING 状态，但不会释放所持有的对象锁；而 <code>wait()</code> 会使线程进入 WAITING &#x2F; TIMED_WAITING 状态，并且会释放对象锁。<br><br>2. <code>wait()</code> 一定要放在 <code>synchronized</code> 中，否则会抛异常；<br><br>3. 必须获得此对象的锁，才能调用这几个方法</td>
</tr>
<tr>
<td>Object.wait(long)</td>
<td></td>
<td>使当前持有该对象锁的线程进入该对象监视器（Monitor）中的 WaitSet 中等待，同时释放对象锁和 CPU 执行权<br><br>最多等待 n 毫秒后自动醒来，不论是否被 <code>notify()</code> 唤醒。</td>
<td>1. 单位是毫秒，1000 毫秒是 1 秒</td>
</tr>
</tbody></table>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotifyDemo</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final Object <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> Object();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> boolean hasData = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 消费者线程</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span> &#123;<br>        @Override<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>            synchronized (<span class="hljs-keyword">lock</span>) &#123;<br>                <span class="hljs-keyword">while</span> (!hasData) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;消费者：没有数据，等待...&quot;</span>);<br>                        <span class="hljs-keyword">lock</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;消费者：拿到了数据，消费完成&quot;</span>);<br>                hasData = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">lock</span>.notify();  <span class="hljs-comment">// 通知生产者可以继续生产</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 生产者线程</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span> &#123;<br>        @Override<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>            synchronized (<span class="hljs-keyword">lock</span>) &#123;<br>                <span class="hljs-keyword">while</span> (hasData) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;生产者：数据未被消费，等待...&quot;</span>);<br>                        <span class="hljs-keyword">lock</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;生产者：生产了数据&quot;</span>);<br>                hasData = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">lock</span>.notify();  <span class="hljs-comment">// 通知消费者可以消费</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>        <span class="hljs-keyword">new</span> Consumer().start();<br>        <span class="hljs-keyword">new</span> Producer().start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="5-4-2-notify-、notifyAll-方法"><a href="#5-4-2-notify-、notifyAll-方法" class="headerlink" title="5.4.2. notify()、notifyAll() 方法"></a>5.4.2. notify()、notifyAll() 方法</h4><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>Object.notify()</td>
<td></td>
<td>唤醒该对象监视器（Monitor）中 WaitSet 中的一个线程</td>
<td>1. 被唤醒的线程进入可运行状态，但尚未持有对象锁，只有在获得 CPU 时间片并成功获取该对象锁后才能继续执行<br><br>2. <code>notify()</code> 一定要放在 <code>synchronized</code> 中，否则会抛异常。<br><br>3. 被唤醒的线程是此前因调用 <code>wait()</code> 而释放该对象锁、并进入等待集的线程；而当前执行 <code>notify()</code> 的线程是持有同一个对象锁的线程。<br><br>4. 必须获得此对象的锁，才能调用这几个方法</td>
</tr>
<tr>
<td>Object.notifyAll()</td>
<td></td>
<td>唤醒该对象监视器（Monitor）中 WaitSet 中的全部线程</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WaitNotifyDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final Object <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> boolean hasData = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 消费者线程</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span> &#123;<br>        @Override<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>            synchronized (<span class="hljs-keyword">lock</span>) &#123;<br>	            <span class="hljs-comment">// 防止线程虚假唤醒</span><br>                <span class="hljs-keyword">while</span> (!hasData) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;消费者：没有数据，等待...&quot;</span>);<br>                        <span class="hljs-keyword">lock</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;消费者：拿到了数据，消费完成&quot;</span>);<br>                hasData = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">lock</span>.notify();  <span class="hljs-comment">// 通知生产者可以继续生产</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 生产者线程</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-title">extends</span> <span class="hljs-title">Thread</span> &#123;<br>        @Override<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>            synchronized (<span class="hljs-keyword">lock</span>) &#123;<br>	            <span class="hljs-comment">// 防止线程虚假唤醒</span><br>                <span class="hljs-keyword">while</span> (hasData) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;生产者：数据未被消费，等待...&quot;</span>);<br>                        <span class="hljs-keyword">lock</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;生产者：生产了数据&quot;</span>);<br>                hasData = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">lock</span>.notify();  <span class="hljs-comment">// 通知消费者可以消费</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>        <span class="hljs-keyword">new</span> Consumer().start();<br>        <span class="hljs-keyword">new</span> Producer().start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项：虚假唤醒</p>
<ol>
<li>虚假唤醒是指线程在没有被明确唤醒（即没有收到 <code>notify()</code> &#x2F; <code>notifyAll()</code> 调用）、也没有超时（对 <code>wait(timeout)</code> 而言）的情况下恢复到了可运行状态。</li>
<li>这并非 Bug，而是 JVM 设计上的一种容忍，但我们为了防止线程在资源尚未准备好时误以为条件满足，我们通常使用 <code>while</code> 循环反复检查条件，从而有效避免虚假唤醒带来的问题。</li>
</ol>
</blockquote>
<hr>
<h2 id="6-线程安全问题"><a href="#6-线程安全问题" class="headerlink" title="6. 线程安全问题"></a>6. 线程安全问题</h2><h3 id="6-1-临界区概述"><a href="#6-1-临界区概述" class="headerlink" title="6.1. 临界区概述"></a>6.1. 临界区概述</h3><p>当一段代码块中存在对共享资源的多线程读写操作，这段代码就称为<strong>临界区</strong>。例如：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> int counter = <span class="hljs-number">0</span>;<br><br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br><br>	Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">		<span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) </span></span><br><span class="hljs-params"><span class="hljs-function">		<span class="hljs-regexp">// 临界区</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">		&#123;	</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">			counter++;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">		&#125;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">	&#125;, &quot;t1&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function"></span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">	Thread t2 = new Thread(() -&gt; &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">		for (int i = 0; i &lt; 5000; i++) </span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">		//</span> 临界区</span></span><br><span class="hljs-params"><span class="hljs-function">		&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">			counter--;</span></span><br><span class="hljs-params"><span class="hljs-function">		&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">	&#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">	<span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">	<span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">	<span class="hljs-title">t1</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">	<span class="hljs-title">t2</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">	<span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(counter)</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>又比如：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> increment() <br>    <span class="hljs-comment">// 临界区</span><br>    &#123; <br>        <span class="hljs-keyword">count</span>++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="6-2-线程安全问题概述"><a href="#6-2-线程安全问题概述" class="headerlink" title="6.2. 线程安全问题概述"></a>6.2. 线程安全问题概述</h3><p>现在有这样一个代码：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">static</span> int counter = <span class="hljs-number">0</span>;<br><br>public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) throws InterruptedException &#123;<br>	Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">		<span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">			counter++;</span></span><br><span class="hljs-params"><span class="hljs-function">		&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">	&#125;, <span class="hljs-string">&quot;t1&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">	<span class="hljs-title">Thread</span> <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">		<span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">			counter--;</span></span><br><span class="hljs-params"><span class="hljs-function">		&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">	&#125;, <span class="hljs-string">&quot;t2&quot;</span>)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">	<span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">	<span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">	<span class="hljs-title">t1</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">	<span class="hljs-title">t2</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">	<span class="hljs-title">System</span>.<span class="hljs-title">out</span>.<span class="hljs-title">println</span><span class="hljs-params">(counter)</span>;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>一个线程对 <code>counter</code> 执行 5000 次加法，另一个线程对 <code>counter</code> 执行 5000 次减法。<strong>按理来说，最终结果应该是 0</strong>，但实际上输出可能是正数、负数，甚至恰好为零。为什么会这样呢？</p>
<p>这是因为 Java 中对静态变量的自增、自减操作<strong>不是原子性的</strong>。要彻底理解这个问题，我们需要先了解 Java 的内存模型（JMM）：<br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250718153733803.png" srcset="/img/loading.gif" lazyload></p>
<p>然后我们要从 字节码层面分析自增、自减的完整过程。以 <code>counter++</code> 为例，Java 编译器会生成以下 JVM 字节码指令：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">getstatic       counter           <span class="hljs-comment">// 获取静态变量 counter 的值</span><br>iconst_1                               <span class="hljs-comment">// 准备常量 1</span><br>iadd                                     <span class="hljs-comment">// 自增</span><br>putstatic       counter           <span class="hljs-comment">// 将修改后的值存入静态变量 counter</span><br></code></pre></td></tr></table></figure>

<p>而 <code>counter--</code> 则会生成类似的指令：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">getstatic       counter          <span class="hljs-comment">// 获取静态变量 counter 的值</span><br>iconst_1                              <span class="hljs-comment">// 准备常量 1</span><br>isub                                    <span class="hljs-comment">// 自减</span><br>putstatic       counter         <span class="hljs-comment">// 将修改后的值存入静态变量 counter</span><br></code></pre></td></tr></table></figure>

<p>假设 <code>counter++</code> 的线程执行到了 <code>iadd</code>，此时 <code>counter</code> 的值为 5，准备通过 <code>putstatic</code> 写入主内存，但就在这一步之前，CPU 的时间片耗尽发生了线程上下文切换。</p>
<p>接着，另一个执行 <code>counter--</code> 的线程获得了 CPU 时间并执行了多次减法操作，将 <code>counter</code> 的值减到 2，并把 2 写回了主内存。之后 <code>counter++</code> 线程恢复执行，继续完成刚才的 <code>putstatic</code>，把原本准备写的 <strong>5</strong> 写回了主内存，覆盖了之前减到 2 的结果，导致最终结果不正确。</p>
<hr>
<h3 id="6-3-线程安全问题分析"><a href="#6-3-线程安全问题分析" class="headerlink" title="6.3. 线程安全问题分析"></a>6.3. 线程安全问题分析</h3><p>一个程序中运行多个线程本身没有问题，关键在于多个线程访问共享资源时的情况：</p>
<ol>
<li>多个线程只读共享资源通常不会有问题；</li>
<li>多个线程中存在读写混合时，就容易出现指令交错，导致读取的数据不是最新的，写入的数据也可能被覆盖，从而引发错误。</li>
</ol>
<hr>
<h3 id="6-4-阻塞式解决方案（悲观锁思想）"><a href="#6-4-阻塞式解决方案（悲观锁思想）" class="headerlink" title="6.4. 阻塞式解决方案（悲观锁思想）"></a>6.4. 阻塞式解决方案（悲观锁思想）</h3><h4 id="6-4-1-锁的分类"><a href="#6-4-1-锁的分类" class="headerlink" title="6.4.1. 锁的分类"></a>6.4.1. 锁的分类</h4><h5 id="6-4-1-1-可重入锁、不可重入锁"><a href="#6-4-1-1-可重入锁、不可重入锁" class="headerlink" title="6.4.1.1. 可重入锁、不可重入锁"></a>6.4.1.1. 可重入锁、不可重入锁</h5><p>可重入锁是指当前线程获取到 A 锁，在获取之后尝试再次获取 A 锁是可以直接拿到的。Java 中提供的 synchronized、ReentrantLock、ReentrantReadWriteLock 都属于可重入锁的实现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MiTest</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> MiTest test;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MiTest</span>()</span> &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MiTest <span class="hljs-title">getInstance</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (test == <span class="hljs-literal">null</span>) &#123;<br>            synchronized (MiTest.<span class="hljs-keyword">class</span>) &#123;<br>                <span class="hljs-keyword">if</span> (test == <span class="hljs-literal">null</span>) &#123;<br>                    test = <span class="hljs-keyword">new</span> MiTest();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> test;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="6-4-1-2-乐观锁、悲观锁"><a href="#6-4-1-2-乐观锁、悲观锁" class="headerlink" title="6.4.1.2. 乐观锁、悲观锁"></a>6.4.1.2. 乐观锁、悲观锁</h5><p>乐观锁认为冲突是小概率事件，访问资源时不加锁，只有在更新时才进行校验。如果检测到资源已被其他线程修改，则放弃本次修改并重试，适用于读多写少的场景。Java 中提供的 CAS 操作，是乐观锁的一种实现方式，而 <code>Atomic</code> 原子类就是基于 CAS 实现的。</p>
<p>而悲观锁基于一种保守假设，只要存在多线程操作共享资源，就极有可能产生冲突。因此，每次访问资源前，线程都会先获取锁，以独占方式持有资源，直到操作完成后释放锁，其它线程需等待锁被释放后才能继续访问。</p>
<p>当无法获取到锁资源时，当前线程会被挂起（进入 BLOCKED 或 WAITING 状态）。线程挂起与唤醒涉及用户态与内核态之间的切换，这种上下文切换是较为耗费系统资源的。</p>
<ol>
<li>用户态：<ol>
<li>指 JVM 能独立完成的操作，不需要操作系统介入。</li>
</ol>
</li>
<li>内存态：<ol>
<li>指必须由操作系统参与、通过系统调用才能完成的操作。</li>
</ol>
</li>
</ol>
<p>Java 中提供的 <code>synchronized</code>、<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 都属于悲观锁的实现。</p>
<hr>
<h5 id="6-4-1-3-公平锁和非公平锁"><a href="#6-4-1-3-公平锁和非公平锁" class="headerlink" title="6.4.1.3. 公平锁和非公平锁"></a>6.4.1.3. 公平锁和非公平锁</h5><p>公平锁是指，当线程 A 获取到锁资源后，线程 B 竞争失败，便进入等待队列排队。此时如果线程 C 也来竞争锁，它会直接排在 B 的后面，只有当 B 获取到锁或取消等待后，C 才有机会尝试获取锁。即，先来先服务，遵循排队原则，防止线程饥饿</p>
<p>而非公平锁是指，线程 A 获取到锁资源，线程 B 竞争失败后进入等待队列。这时线程 C 到来，不会直接排队，而是会先尝试竞争一波：</p>
<ol>
<li>若成功获取锁：<ol>
<li>插队成功，直接执行，破坏了队列公平性。</li>
</ol>
</li>
<li>若竞争失败：<ol>
<li>才会排到 B 后面，继续等待获取锁或等 B 放弃后再次尝试。</li>
</ol>
</li>
</ol>
<p>Java 中的 <code>synchronized</code> 只能实现非公平锁，而 <code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 则支持公平锁和非公平锁两种模式。</p>
<hr>
<h5 id="6-4-1-4-互斥锁、共享锁"><a href="#6-4-1-4-互斥锁、共享锁" class="headerlink" title="6.4.1.4. 互斥锁、共享锁"></a>6.4.1.4. 互斥锁、共享锁</h5><p>互斥锁是指，在同一时刻，只有一个线程能够持有该锁，其它线程必须等待锁被释放后才能竞争获取。</p>
<p>而共享锁是指，在同一时刻，该锁可以被多个线程同时持有，多个线程可以并发访问共享资源（通常是只读操作）。</p>
<p>Java 中的 <code>synchronized</code>、<code>ReentrantLock</code> 只能实现互斥锁，而 <code>ReentrantReadWriteLock</code> 则支持互斥锁和共享锁两种模式。</p>
<hr>
<h4 id="6-4-2-synchronized"><a href="#6-4-2-synchronized" class="headerlink" title="6.4.2. synchronized"></a>6.4.2. synchronized</h4><h5 id="6-4-2-1-synchronized-基本使用"><a href="#6-4-2-1-synchronized-基本使用" class="headerlink" title="6.4.2.1. synchronized 基本使用"></a>6.4.2.1. synchronized 基本使用</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        counter++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123;<br>        counter--;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title">getCounter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>静态方法加 <code>synchronized static</code> 时，锁的是该类的 Class 对象</li>
<li>普通方法加 <code>synchronized</code> 时，锁的是当前对象（<code>this</code>），其可以简写为：</li>
</ol>
</blockquote>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 1. 写法 1</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>		counter++;<br>	&#125;<br>&#125;<br><br><br><span class="hljs-comment">// 2. 写法 2</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>	counter++;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="6-4-2-2-synchronized-底层原理"><a href="#6-4-2-2-synchronized-底层原理" class="headerlink" title="6.4.2.2. synchronized 底层原理"></a>6.4.2.2. synchronized 底层原理</h5><h6 id="6-4-2-2-1-Java-对象头"><a href="#6-4-2-2-1-Java-对象头" class="headerlink" title="6.4.2.2.1. Java 对象头"></a>6.4.2.2.1. Java 对象头</h6><p>通常我们的一个 Java 对象，他在内存中由两部分组成，一部分是 Java 对象头，一部分是对象中的一些成员变量，对于 对象头而言，以 32 位虚拟机为例：</p>
<p><font color="#92d050">1. 普通对象</font><br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250718231947171.png" srcset="/img/loading.gif" lazyload></p>
<p><font color="#92d050">2. 数组对象</font><br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250718232007146.png" srcset="/img/loading.gif" lazyload></p>
<p><font color="#92d050">3. Mark Word</font><br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719085830451.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h6 id="6-4-2-2-2-Monitor"><a href="#6-4-2-2-2-Monitor" class="headerlink" title="6.4.2.2.2. Monitor"></a>6.4.2.2.2. Monitor</h6><p>Monitor（可译为 “监视器” 或 “管程”）是 JVM 内部专门用于实现重量级锁的结构。当一个 Java 对象升级为重量级锁时，JVM 会为其关联一个 Monitor 对象，用于协调多线程之间对该对象的互斥访问。<br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719102443800.png" srcset="/img/loading.gif" lazyload></p>
<p>当 Thread 1 执行完临界区代码后，会根据线程中保存的指向 Object 的地址找到该对象，再通过对象头中指向的 Monitor 地址找到 Monitor 对象，将其 Owner 设置为 null，并唤醒 EntryList 中所有等待的线程，这些线程随后开始竞争锁的拥有权。</p>
<hr>
<h6 id="6-4-2-2-3-轻量级锁"><a href="#6-4-2-2-3-轻量级锁" class="headerlink" title="6.4.2.2.3. 轻量级锁"></a>6.4.2.2.3. 轻量级锁</h6><p>考虑到重量级锁的性能问题，锁竞争时线程需要挂起与唤醒，会触发操作系统层面的上下文切换，代价极高，动辄消耗数万 CPU 周期。同时，频繁的线程阻塞还可能带来调度延迟、缓存失效等额外副作用。</p>
<p>而现实中，大多数锁的竞争程度其实并不高：很多临界区的代码执行极快，线程间访问呈错峰分布，根本不会产生真正的冲突；即便发生竞争，通常也只是短暂的、少数线程的重叠访问。这种情况下，一个线程已迅速完成执行，而另一个线程却仍在挂起、唤醒、重新调度的过程中。更何况，即使没有阻塞与唤醒，重量级锁的加锁与解锁过程本身也不轻。因此，为了提升并发性能，在这类 “低冲突、短执行” 的场景中，Java 官方将重量级锁优化为轻量级锁，语法不变</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span>&#123;<br>        counter++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span>&#123;<br>        counter--;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title">getCounter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> counter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在有线程去调用 synchronized 的方法，会在其线程栈帧中创建一个锁记录（Lock Record）。<br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719100014731.png" srcset="/img/loading.gif" lazyload></p>
<p>接着，线程尝试给对象加轻量级锁，操作流程是：先让 Object reference 指向对象地址，并使用 CAS（原子操作）尝试将锁记录的地址与对象头中的 Mark Word 交换。<br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719100114713.png" srcset="/img/loading.gif" lazyload></p>
<p>如果 CAS 替换成功，对象头中就存储了锁记录的地址（因为需要记录是哪个线程拥有该对象的锁），此时 Object 的状态为 00，表示对象持有轻量级锁。当临界区代码执行完毕，锁记录会被交换回对象头。<br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719100159695.png" srcset="/img/loading.gif" lazyload alt="|850"></p>
<p>如果 CAS 失败，但，是当前线程在执行 synchronized 发生重入，会添加一条新的锁记录作为重入计数。锁记录数量表示该线程对该对象加锁的次数，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">static</span> final <span class="hljs-title class_">Object</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method1</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">obj</span>) &#123;<br>        <span class="hljs-title function_">method2</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">method2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">obj</span>) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719100555573.png" srcset="/img/loading.gif" lazyload></p>
<p>如果 CAS 失败且发生线程竞争，当前线程会进行多次自旋尝试（赌其他线程能快速释放锁，避免像重量级锁一样直接挂起带来的性能损耗）。若多次尝试仍未成功，则发生锁膨胀，锁会升级为重量级锁。</p>
<p>假设 Thread 0 已持有轻量级锁，但 Thread 1 多次自旋均未成功，<br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719101118338.png" srcset="/img/loading.gif" lazyload></p>
<p>这时 JVM 会为该对象分配一个 Monitor 对象，将对象头中原先指向锁记录的 Mark Word 替换为指向 Monitor 的指针，Thread 1 被加入 Monitor 的 EntryList 队列挂起，Monitor 的 Owner 指向 Thread 0。<br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719101521799.png" srcset="/img/loading.gif" lazyload></p>
<p>当 Thread 0 执行完临界区代码，需要解锁时，会先尝试通过 CAS 将锁记录恢复到对象头（Mark Word），肯定发生失败，进入重量级锁解锁流程。  </p>
<p>解锁时，线程会根据线程中保存的指向 Object 的地址找到该对象，再通过对象头中指向的 Monitor 地址找到 Monitor 对象，将其 Owner 设置为 null，并唤醒 EntryList 中所有等待的线程，这些线程随后开始竞争锁的拥有权。</p>
<p>虽然轻量级锁相比不加锁确实带来了一些额外成本（但共享资源操作必须加锁），例如每次进入锁时需要创建锁记录、执行 CAS 操作，并且存在短暂的自旋，可能会消耗一些 CPU 周期；</p>
<p>但轻量级锁有效避免了线程阻塞和唤醒的开销，在大多数 “无锁竞争” 或 “低冲突” 的场景下，能够以极低的成本完成加锁与释放，因此整体性能远远优于重量级锁。</p>
<hr>
<h6 id="6-4-2-2-4-偏向锁"><a href="#6-4-2-2-4-偏向锁" class="headerlink" title="6.4.2.2.4. 偏向锁"></a>6.4.2.2.4. 偏向锁</h6><p>偏向锁是在轻量级锁基础上的进一步优化，其设计初衷是为了在无竞争的场景下提升锁操作的性能。</p>
<p>然而，随着硬件性能提升和虚拟机其他优化手段的发展，偏向锁带来的性能收益已逐渐减弱，同时其实现的复杂性也成为阻碍 JVM 进一步优化的负担。因此，Oracle 在 JDK 15 中将偏向锁标记为废弃，并在 JDK 17 中将其彻底移除。若使用的是 JDK8，偏向锁默认是开启的，我们需要通过在 JVM 启动参数中添加配置来显式禁止偏向锁。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:-UseBiasedLocking</span><br></code></pre></td></tr></table></figure>

<hr>
<h5 id="6-4-2-3-synchronized-高级使用"><a href="#6-4-2-3-synchronized-高级使用" class="headerlink" title="6.4.2.3. synchronized 高级使用"></a>6.4.2.3. synchronized 高级使用</h5><p>对于下面的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Room</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span>()</span> &#123;<br>        synchronized (<span class="hljs-keyword">this</span>) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span>()</span> &#123;<br>        synchronized (<span class="hljs-keyword">this</span>) &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然 <code>study()</code> 方法和 <code>sleep()</code> 方法本身没有逻辑上的交集，但如果某个线程调用了带有 <code>synchronized</code> 的 <code>sleep()</code> 方法，就会导致该对象，甚至可能是整个类被加锁。这样一来，其他线程即使只是想调用 <code>study()</code> 方法，也必须等到前一个线程释放锁后才能执行。这种做法不利于并发性能的提升，因此我们可以通过引入多把锁来进行优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Room</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">studyRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">bedRoom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (bedRoom) &#123;<br>            System.out.println(<span class="hljs-string">&quot;sleeping 2 小时&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (studyRoom) &#123;<br>            System.out.println(<span class="hljs-string">&quot;study 1 小时&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="6-4-3-ReentrantLock"><a href="#6-4-3-ReentrantLock" class="headerlink" title="6.4.3. ReentrantLock"></a>6.4.3. ReentrantLock</h4><h5 id="6-4-3-1-ReentrantLock-与-synchronized-的区别"><a href="#6-4-3-1-ReentrantLock-与-synchronized-的区别" class="headerlink" title="6.4.3.1. ReentrantLock 与 synchronized 的区别"></a>6.4.3.1. ReentrantLock 与 synchronized 的区别</h5><h3 id="6-5-非阻塞式解决方案（乐观锁思想）"><a href="#6-5-非阻塞式解决方案（乐观锁思想）" class="headerlink" title="6.5. 非阻塞式解决方案（乐观锁思想）"></a>6.5. 非阻塞式解决方案（乐观锁思想）</h3><h4 id="6-5-1-CAS"><a href="#6-5-1-CAS" class="headerlink" title="6.5.1. CAS"></a>6.5.1. CAS</h4><p>CAS，全称为 Compare-And-Swap，中文意为“比较并交换”，是并发编程中最基础且关键的原子操作之一。通俗地说，CAS 的含义是：先检查当前主内存中的值是否与我预期的一致，如果一致，就将其更新为新值；否则，说明有其他线程修改过该值，此时我不会进行任何操作。</p>
<p>CAS 操作涉及三个核心参数：</p>
<ol>
<li>V：<ol>
<li>当前主内存中的实际值（Current value）</li>
</ol>
</li>
<li>E：<ol>
<li>线程期望该变量拥有的值（Expected value）</li>
</ol>
</li>
<li>N：<ol>
<li>需要更新的新值（New value）</li>
</ol>
</li>
</ol>
<p>下面的代码展示了一个典型的 CAS 操作过程：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> withdraw(Integer amount) &#123;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <br>	    <span class="hljs-comment">// 将当前主内存中的值加载到工作内存</span><br>        <span class="hljs-built_in">int</span> prev = balance.get();<br>        <br>        <span class="hljs-comment">// 在工作内存中计算新的结果</span><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">next</span> = prev - amount;<br>        <br>        <span class="hljs-comment">// 比较并尝试设置结果到主内存，设置失败将重新循环</span><br>        <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, <span class="hljs-keyword">next</span>)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码的关键在于 <code>compareAndSet</code> 方法。它是一个原子操作，也必须具备原子性，才能保证在多线程环境下数据更新的正确性。其底层依赖于硬件提供的原子指令（如 x86 架构中的 <code>cmpxchg</code>），从而实现了线程安全的变量更新逻辑。它所完成的功能是：<br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250720093607520.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>CAS 必须结合 <code>volatile</code> 使用。Java 提供的各类原子变量（如 <code>AtomicInteger</code>）底层都通过 <code>volatile</code> 修饰共享变量。这是因为无论是读取当前值，还是进行比较并交换操作，都必须确保读取到的是主内存中的最新值，才能保证线程之间的可见性和操作的正确性</li>
<li>由于 CAS 并未使用 <code>synchronized</code>，线程在竞争时不会陷入 <code>BLOCKED</code> 状态，也不会触发锁的升级过程，这是它能够提升并发性能的重要原因之一。<br>然而，CAS 更适用于线程数量较少、CPU 核心数较多的场景，因为它采用的是 <code>while</code> 自旋的方式不断重试，会让 CPU 保持持续高频运转。一旦线程数过多，反复重试拉满 CPU，造成大量 CPU 资源浪费，进而导致性能大幅下降</li>
</ol>
</blockquote>
<hr>
<h4 id="6-5-2-原子变量"><a href="#6-5-2-原子变量" class="headerlink" title="6.5.2. 原子变量"></a>6.5.2. 原子变量</h4><h5 id="6-5-2-1-AtomicBoolean"><a href="#6-5-2-1-AtomicBoolean" class="headerlink" title="6.5.2.1. AtomicBoolean"></a>6.5.2.1. AtomicBoolean</h5><hr>
<h5 id="6-5-2-2-AtomicInteger"><a href="#6-5-2-2-AtomicInteger" class="headerlink" title="6.5.2.2. AtomicInteger"></a>6.5.2.2. AtomicInteger</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;<br><br>    <span class="hljs-keyword">static</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br><br>        System.<span class="hljs-keyword">out</span>.println(atomicInteger.incrementAndGet()); <span class="hljs-comment">// ++i，先自增，然后返回结果</span><br><br>        System.<span class="hljs-keyword">out</span>.println(atomicInteger.getAndIncrement()); <span class="hljs-comment">// i++，先返回当前值，然后再自增</span><br><br>        System.<span class="hljs-keyword">out</span>.println(atomicInteger.decrementAndGet()); <span class="hljs-comment">// --i</span><br><br>        System.<span class="hljs-keyword">out</span>.println(atomicInteger.getAndIncrement()); <span class="hljs-comment">// i--</span><br><br>        atomicInteger.updateAndGet(<span class="hljs-keyword">value</span> -&gt; <span class="hljs-keyword">value</span> * <span class="hljs-number">10</span>); <span class="hljs-comment">// 先执行操作，然后返回结果</span><br><br>        atomicInteger.getAndUpdate(<span class="hljs-keyword">value</span> -&gt; <span class="hljs-keyword">value</span> * <span class="hljs-number">10</span>); <span class="hljs-comment">// 先返回当前值，然后再执行操作</span><br><br>        System.<span class="hljs-keyword">out</span>.println(atomicInteger.<span class="hljs-keyword">get</span>()); <span class="hljs-comment">// 读取当前值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="6-5-2-3-AtomicIntegerArray"><a href="#6-5-2-3-AtomicIntegerArray" class="headerlink" title="6.5.2.3. AtomicIntegerArray"></a>6.5.2.3. AtomicIntegerArray</h5><hr>
<h5 id="6-5-2-4-AtomicIntegerFieldUpdater"><a href="#6-5-2-4-AtomicIntegerFieldUpdater" class="headerlink" title="6.5.2.4. AtomicIntegerFieldUpdater"></a>6.5.2.4. AtomicIntegerFieldUpdater</h5><hr>
<h5 id="6-5-2-5-AtomicLong"><a href="#6-5-2-5-AtomicLong" class="headerlink" title="6.5.2.5. AtomicLong"></a>6.5.2.5. AtomicLong</h5><hr>
<h5 id="6-5-2-6-AtomicLongArray"><a href="#6-5-2-6-AtomicLongArray" class="headerlink" title="6.5.2.6. AtomicLongArray"></a>6.5.2.6. AtomicLongArray</h5><hr>
<h5 id="6-5-2-7-AtomicLongFieldUpdater"><a href="#6-5-2-7-AtomicLongFieldUpdater" class="headerlink" title="6.5.2.7. AtomicLongFieldUpdater"></a>6.5.2.7. AtomicLongFieldUpdater</h5><hr>
<h2 id="7-线程池"><a href="#7-线程池" class="headerlink" title="7. 线程池"></a>7. 线程池</h2><h3 id="7-1-线程池概述"><a href="#7-1-线程池概述" class="headerlink" title="7.1. 线程池概述"></a>7.1. 线程池概述</h3><h5 id="7-1-1-1-AtomicReference"><a href="#7-1-1-1-AtomicReference" class="headerlink" title="7.1.1.1. AtomicReference"></a>7.1.1.1. AtomicReference</h5><hr>
<h5 id="7-1-1-2-AtomicReferenceArray"><a href="#7-1-1-2-AtomicReferenceArray" class="headerlink" title="7.1.1.2. AtomicReferenceArray"></a>7.1.1.2. AtomicReferenceArray</h5><hr>
<h5 id="7-1-1-3-AtomicReferenceFieldUpdater"><a href="#7-1-1-3-AtomicReferenceFieldUpdater" class="headerlink" title="7.1.1.3. AtomicReferenceFieldUpdater"></a>7.1.1.3. AtomicReferenceFieldUpdater</h5><hr>
<h5 id="7-1-1-4-AtomicMarkableReference"><a href="#7-1-1-4-AtomicMarkableReference" class="headerlink" title="7.1.1.4. AtomicMarkableReference"></a>7.1.1.4. AtomicMarkableReference</h5><hr>
<h5 id="7-1-1-5-AtomicStampedReference"><a href="#7-1-1-5-AtomicStampedReference" class="headerlink" title="7.1.1.5. AtomicStampedReference"></a>7.1.1.5. AtomicStampedReference</h5><hr>
<h2 id="8-线程的活跃性"><a href="#8-线程的活跃性" class="headerlink" title="8. 线程的活跃性"></a>8. 线程的活跃性</h2><h3 id="8-1-死锁"><a href="#8-1-死锁" class="headerlink" title="8.1. 死锁"></a>8.1. 死锁</h3><h4 id="8-1-1-死锁概述"><a href="#8-1-1-死锁概述" class="headerlink" title="8.1.1. 死锁概述"></a>8.1.1. 死锁概述</h4><p>当一个线程需要同时获取多把锁时，就容易发生死锁。例如，线程 t1 先获得了 A 对象的锁，接下来试图获取 B 对象的锁；与此同时，线程 t2 已经获得了 B 对象的锁，并准备去获取 A 对象的锁。此时两个线程互相等待对方释放锁，便形成了死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runT1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (A) &#123;<br>            System.out.println(<span class="hljs-string">&quot;t1 获得 A&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">synchronized</span> (B) &#123;<br>                System.out.println(<span class="hljs-string">&quot;t1 获得 B&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;t1 执行操作...&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runT2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (B) &#123;<br>            System.out.println(<span class="hljs-string">&quot;t2 获得 B&quot;</span>);<br>            sleep(<span class="hljs-number">500</span>);<br>            <span class="hljs-keyword">synchronized</span> (A) &#123;<br>                System.out.println(<span class="hljs-string">&quot;t2 获得 A&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;t2 执行操作...&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(millis);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br>	<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Test::runT1, <span class="hljs-string">&quot;t1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Test::runT2, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="8-1-2-死锁定位"><a href="#8-1-2-死锁定位" class="headerlink" title="8.1.2. 死锁定位"></a>8.1.2. 死锁定位</h4><h5 id="8-1-2-1-jconsole-定位死锁"><a href="#8-1-2-1-jconsole-定位死锁" class="headerlink" title="8.1.2.1. jconsole 定位死锁"></a>8.1.2.1. jconsole 定位死锁</h5><p><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719183232957.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h4 id="8-1-3-死锁解决方案"><a href="#8-1-3-死锁解决方案" class="headerlink" title="8.1.3. 死锁解决方案"></a>8.1.3. 死锁解决方案</h4><hr>
<h3 id="8-2-活锁"><a href="#8-2-活锁" class="headerlink" title="8.2. 活锁"></a>8.2. 活锁</h3><h4 id="8-2-1-活锁概述"><a href="#8-2-1-活锁概述" class="headerlink" title="8.2.1. 活锁概述"></a>8.2.1. 活锁概述</h4><p>活锁虽然名字中带有“锁”，但它并不是由我们显式加上的锁造成的，而是指两个线程不断互相改变对方的终止条件，导致最终双方都无法完成或结束的情况。</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLiveLock</span> &#123;<br><br>    <span class="hljs-keyword">static</span> volatile <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> sleep(<span class="hljs-built_in">double</span> seconds) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep((<span class="hljs-built_in">long</span>) (seconds * <span class="hljs-number">1000</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望减到 0 退出循环</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">count</span> &gt; <span class="hljs-number">0</span>) &#123;<br>                sleep(<span class="hljs-number">0.2</span>);<br>                <span class="hljs-keyword">count</span>--;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, <span class="hljs-keyword">count</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望超过 20 退出循环</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">count</span> &lt; <span class="hljs-number">20</span>) &#123;<br>                sleep(<span class="hljs-number">0.2</span>);<br>                <span class="hljs-keyword">count</span>++;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, <span class="hljs-keyword">count</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="8-2-2-活锁解决方案"><a href="#8-2-2-活锁解决方案" class="headerlink" title="8.2.2. 活锁解决方案"></a>8.2.2. 活锁解决方案</h4><hr>
<h1 id="——————"><a href="#——————" class="headerlink" title="——————"></a>——————</h1><h2 id="1-自己写的，超级不错"><a href="#1-自己写的，超级不错" class="headerlink" title="1. 自己写的，超级不错"></a>1. 自己写的，超级不错</h2><h3 id="1-1-线程安全问题"><a href="#1-1-线程安全问题" class="headerlink" title="1.1. 线程安全问题"></a>1.1. 线程安全问题</h3><h4 id="1-1-1-线程安全问题概述"><a href="#1-1-1-线程安全问题概述" class="headerlink" title="1.1.1. 线程安全问题概述"></a>1.1.1. 线程安全问题概述</h4><p>在 Spring 中，我们通常会将某个类声明为 Bean，并通过依赖注入的方式在其他地方调用它的方法。也就是说，不管有多少个调用，最终操作的都是这个单例 Bean 的同一个实例。那么现在问题来了，如果我们将下面这段代码声明为 Bean：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs axapta">@Service  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterService</span> &#123;  <br>  <br>    <span class="hljs-comment">// 成员变量 totalCount</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> totalCount = <span class="hljs-number">0</span>;  <br><br>	<span class="hljs-comment">// 参数 count</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> addCount(<span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>) &#123;  <br>	    <span class="hljs-comment">// 局部变量 c</span><br>	    <span class="hljs-built_in">int</span> c = <span class="hljs-number">10</span>;<br>        totalCount += <span class="hljs-keyword">count</span>;  <br>        <span class="hljs-keyword">return</span> totalCount;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>


<p>并在其他组件中注入并调用它的方法：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@RestController</span><br><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/counter&quot;</span>)<br>public class CounterController &#123;<br>	<br>    <span class="hljs-variable">@Autowired</span><br>    private CounterService counterService;<br><br>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/add&quot;</span>)<br>    public int <span class="hljs-built_in">addCount</span>(<span class="hljs-variable">@RequestParam</span> int value) &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">counterService</span><span class="hljs-selector-class">.addCount</span>(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在传统的 Tomcat 服务器中，每个 HTTP 请求会由一个独立的线程处理，当这个线程调用 <code>addCount()</code> 方法时：</p>
<ol>
<li>方法参数 <code>count</code> 和局部变量 <code>c</code> 是线程私有的，分配在各自线程的栈内存中，每个线程都有独立副本，互不干扰，因此天然线程安全</li>
<li>而 <code>totalCount</code> 是 Bean 的成员变量，存放在堆内存中，为所有线程所共享，因此存在并发读写的风险。</li>
</ol>
<p>因此，一旦多个请求同时调用该方法，就会触发<strong>竞态条件</strong>：线程们在没有排队的情况下同时抢着修改 <code>totalCount</code>，导致返回的结果不可靠、不确定、不可预测，产生严重的数据错误。</p>
<p>举个例子：A 线程读取到 <code>totalCount = 10</code>，打算加 5；B 线程同样读取到 10，打算加 7。它们各自完成加法并写回后，可能的结果包括：A 返回 15，B 返回 17；或者 A 返回 17，B 返回 15；甚至 A 返回 17，B 返回 22。注意，这还只是两个线程的情况，在高并发下，<code>totalCount</code> 的最终值将更加不可预测，容易造成严重的数据混乱。</p>
<p><font color="#ff0000">所以这就是为什么我们的大多数服务和组件都设计为无状态的——也就是说，不在 Bean 中存放可变的成员变量。（不是不放成员变量，而是不放可变的成员变量）</font></p>
<hr>
<h4 id="1-1-2-解决普通服务线程安全问题"><a href="#1-1-2-解决普通服务线程安全问题" class="headerlink" title="1.1.2. 解决普通服务线程安全问题"></a>1.1.2. 解决普通服务线程安全问题</h4><p>为了解决线程安全问题，最理想的做法就是避免在 Bean 中存放可变的成员变量，而是将变量限定为线程私有。但如果业务上确实需要使用成员变量，我们也可以采取以下措施：<br>&#x3D;&#x3D;1.使用线程安全的数据结构（推荐）&#x3D;&#x3D;<br>这些数据结构内部采用了复杂的机制，保证每次更新都是原子操作，同时避免线程阻塞和锁竞争，性能远超 <code>synchronized</code>。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterService</span> </span>&#123;<br><br>    <span class="hljs-comment">// 使用 AtomicInteger 保证线程安全</span><br>    <span class="hljs-keyword">private</span> AtomicInteger totalCount = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> totalCount.<span class="hljs-title">addAndGet</span><span class="hljs-params">(count)</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>&#x3D;&#x3D;2.方法加锁&#x3D;&#x3D;<br>给方法加 <code>synchronized</code> 锁后，所有调用都会排队，导致性能下降。比如下面这个例子：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Service</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterService</span> </span>&#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> totalCount = <span class="hljs-number">0</span>;  <br><br>    <span class="hljs-comment">// 给方法加 synchronized 锁住整个方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;  <br>        <span class="hljs-keyword">int</span> c = <span class="hljs-number">10</span>;<br>        totalCount += count;  <br>        <span class="hljs-keyword">return</span> totalCount;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>当一个线程调用 <code>addCount</code> 方法时，整个实例对象（即 <code>this</code>）会被锁定。也就是说，该对象内所有被 <code>synchronized</code> 修饰的实例方法都会被阻塞，直到锁释放。但如果对象内存在未加锁的方法，则不会受到影响，仍可正常调用。</p>
<p>因此，我们建议只对修改共享成员变量的公共方法加锁，不涉及共享状态的其他方法则尽量避免加锁，以减少性能损耗。</p>
<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>普通实例方法加 <code>synchronized</code> 时，锁的是当前对象实例（<code>this</code>）</li>
<li>静态方法加 <code>synchronized static</code> 时，锁的是该类的 Class 对象，所有实例共享同一把锁，所有实例都被锁了，但没加锁的方法，都不会被阻塞，照样可以调用</li>
</ol>
</blockquote>
<p>&#x3D;&#x3D;3.代码块加锁&#x3D;&#x3D;<br>它不是给整个方法加锁，而是在方法内部用一对大括号包裹的代码块，加上 <code>synchronized</code> 关键字，只锁本对象的代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterService</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">totalCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <span class="hljs-comment">// 自定义锁对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addCount</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;  <span class="hljs-comment">// 只锁住对共享变量的操作</span><br>            totalCount += count;  <br>        &#125;<br><br>        <span class="hljs-keyword">return</span> totalCount;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>


<p>&#x3D;&#x3D;4.可变状态放到外部系统（推荐）&#x3D;&#x3D;<br>我们将可变状态甩给外部系统，比如数据库、Redis、消息队列等，从而避免在 Java 服务内部处理线程安全问题。你可能会疑惑：把状态交给它们后，难道外部系统就不会有线程安全问题吗？</p>
<p>实际上，这些外部系统天生具备强大的并发控制能力，能够帮我们确保状态的一致性。以数据库为例，它天然支持事务和行级锁，即使有上千个线程同时写入，也能通过行锁、MVCC（多版本并发控制）和隔离级别等机制，有效地管理并发访问，保证数据安全和一致。</p>
<hr>
<h4 id="1-1-3-解决外部连接服务线程安全问题"><a href="#1-1-3-解决外部连接服务线程安全问题" class="headerlink" title="1.1.3. 解决外部连接服务线程安全问题"></a>1.1.3. 解决外部连接服务线程安全问题</h4><p>上文我们讲完了普通服务中的线程安全问题和解决方案，但如果该服务涉及外部连接（如数据库、FTP、Redis 等），情况就会变得更复杂，比如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedJedisClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Jedis</span> jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getValue</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> key</span>) &#123;<br>        <span class="hljs-keyword">return</span> jedis.<span class="hljs-title function_">get</span>(key);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setValue</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> key, <span class="hljs-title class_">String</span> value</span>) &#123;<br>        jedis.<span class="hljs-title function_">set</span>(key, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个 Bean 在初始化时就创建了一个 TCP 连接，之后的方法直接使用这个连接执行操作。表面上看，这个 Bean 并没有定义可变的成员变量，连接对象也没在方法中被修改，似乎一切很安全对吧？</p>
<p>但其实存在严重的线程安全隐患。因为多个线程如果同时调用这个 Bean 中的方法，它们会共享同一个连接对象，导致线程之间对连接的操作交叉进行，可能发生数据错乱、粘包拆包、读写冲突等问题。</p>
<p>你可能会想，那我不共享连接，每个方法里都 <code>new</code> 一个连接，岂不就天然线程安全了？确实，这样做可以保证线程隔离，但代价也很高。频繁地创建和销毁连接（尤其是 TCP 连接）会造成巨大的性能开销，严重影响系统吞吐量，并不是理想的做法。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">NewPerCallJedisClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getValue(<span class="hljs-keyword">String</span> key) &#123;<br>        <span class="hljs-keyword">try</span> (Jedis jedis = <span class="hljs-keyword">new</span><span class="hljs-type"></span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>)) &#123;<br>            <span class="hljs-keyword">return</span> jedis.<span class="hljs-keyword">get</span>(key);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> void setValue(<span class="hljs-keyword">String</span> key, <span class="hljs-keyword">String</span> value) &#123;<br>        <span class="hljs-keyword">try</span> (Jedis jedis = <span class="hljs-keyword">new</span><span class="hljs-type"></span> Jedis(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>)) &#123;<br>            jedis.<span class="hljs-keyword">set</span>(key, value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我们尝试套用前面解决普通服务线程安全问题的那四种方法，虽然能避免线程冲突，但往往会带来额外的性能开销，尤其是在涉及连接操作时，代价更高。</p>
<p>其实，我们还有一种更高效的解决方案 —— 连接池。连接池被我们设置为公用的成员变量，所有调用该 Bean 的线程都可以使用它。在每次方法调用时，线程会从连接池中借出一个连接，执行完操作后再归还池中。</p>
<p>这样既能做到多线程各用自己的连接，避免线程安全问题，又能通过连接复用来减少频繁创建&#x2F;销毁连接的开销，兼顾了线程安全与系统性能。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">PooledJedisClient</span> </span>&#123;<br>    <span class="hljs-comment">// 在应用启动时创建连接池</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JedisPool pool = <span class="hljs-keyword">new</span><span class="hljs-type"></span> JedisPool(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getValue(<span class="hljs-keyword">String</span> key) &#123;<br>        <span class="hljs-comment">// 从池里借一个 Jedis 实例，操作完自动归还</span><br>        <span class="hljs-keyword">try</span> (Jedis jedis = pool.getResource()) &#123;<br>            <span class="hljs-keyword">return</span> jedis.<span class="hljs-keyword">get</span>(key);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> void setValue(<span class="hljs-keyword">String</span> key, <span class="hljs-keyword">String</span> value) &#123;<br>        <span class="hljs-keyword">try</span> (Jedis jedis = pool.getResource()) &#123;<br>            jedis.<span class="hljs-keyword">set</span>(key, value);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li><code>Netty</code> 好像也能处理这个事情，Redis 就是使用的这个方式，还维护自己的一套nid 线程池？不理解不理解</li>
</ol>
</blockquote>
<hr>
<h1 id="———"><a href="#———" class="headerlink" title="———-"></a>———-</h1><h2 id="1-并发编程三大特性"><a href="#1-并发编程三大特性" class="headerlink" title="1. 并发编程三大特性"></a>1. 并发编程三大特性</h2><h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1. 原子性"></a>1.1. 原子性</h3><p>原子性是指，保证指令不会受到线程上下文切换的影响。</p>
<hr>
<h3 id="1-2-可见性"><a href="#1-2-可见性" class="headerlink" title="1.2. 可见性"></a>1.2. 可见性</h3><h4 id="1-2-1-可见性概述"><a href="#1-2-1-可见性概述" class="headerlink" title="1.2.1. 可见性概述"></a>1.2.1. 可见性概述</h4><p>可见性是指，当一个线程修改了共享变量的值，其他线程能够立即知道这个修改，保证指令不会受 cpu 缓存的影响。首先我们来看一个代码：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-type">boolean</span> run = <span class="hljs-literal">true</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (run) &#123;<br>            <span class="hljs-comment">// 业务逻辑</span><br>        &#125;<br>    &#125;).<span class="hljs-built_in">start</span>();<br><br>    Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br><br>    run = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>按理来说，<code>run = false</code> 应该能使线程退出循环，但是实际上，线程并不会立即退出循环，而是会继续执行循环体中的代码。这是因为，<code>run</code> 变量被修改后，线程并不知道这个变化，它仍然使用的是旧值，所以会继续执行循环体中的代码。</p>
<p>其实本质原因是，在线程初始化时，会将 <code>run</code> 变量的值从主内存复制到线程的工作内存中：<br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719223150888.png" srcset="/img/loading.gif" lazyload></p>
<p>执行一次就要从主内存中读取一次，应为线程频繁从主内存中读取run 的值，JIT 会将 run 变量的值缓存到线程的工作内存中的高速缓存中，避免每次都从主内存中读取，从而提高效率。<br><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719223516927.png" srcset="/img/loading.gif" lazyload></p>
<p>这种优化本意是好的，但是也带来了可见性问题：main 线程修改了 <code>run</code> 变量的值，并同步至主内存，但是线程并不知道这个变化，它仍然使用的是旧值，所以会继续执行循环体中的代码。</p>
<p><img src="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9AJUC/image-20250719223757282.png" srcset="/img/loading.gif" lazyload></p>
<hr>
<h4 id="1-2-2-可见性问题解决方案"><a href="#1-2-2-可见性问题解决方案" class="headerlink" title="1.2.2. 可见性问题解决方案"></a>1.2.2. 可见性问题解决方案</h4><h5 id="1-2-2-1-volatile-解决方案"><a href="#1-2-2-1-volatile-解决方案" class="headerlink" title="1.2.2.1. volatile 解决方案"></a>1.2.2.1. volatile 解决方案</h5><p>想解决这个问题其实很简单，我们只需为共享变量添加一个新的修饰符 <code>volatile</code>。这个关键字的含义是“易变的”，也就是说，加上 <code>volatile</code> 之后，变量的值不能再从线程的本地缓存中读取，而是每次都必须从主内存中读取最新的值。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> run = <span class="hljs-literal">true</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> throws InterruptedException </span>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (run) &#123;<br>            <span class="hljs-comment">// 业务逻辑</span><br>        &#125;<br>    &#125;).<span class="hljs-built_in">start</span>();<br><br>    Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br><br>    run = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然这样做在性能上会有一定的损失，但它确保了多个线程之间对共享变量的可见性，也就是说，一个线程修改了变量的值，其他线程能够及时看到这个变化。</p>
<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>volatile 可以用来修饰成员变量和静态变量，不用用来修饰局部变量</li>
<li>volatile 的本质是基于读写屏障来保证可见性的：</li>
</ol>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 写屏障（sefence）</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 当对被 volatile 修饰的成员变量或静态变量进行写操作时</span><br><span class="hljs-comment"> * 编译器会在该语句之后插入一条写屏障指令</span><br><span class="hljs-comment"> * 写屏障用于确保在该屏障之前，对所有共享变量的修改</span><br><span class="hljs-comment"> * 都被刷新到主内存中，从而保证写操作对其他线程可见。</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">()</span> </span>&#123;<br>    num = <span class="hljs-number">1</span>; <span class="hljs-comment">// num 是普通的共享变量，也会被同步到主内存</span><br>    ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 变量</span><br>    <span class="hljs-comment">// 写屏障</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 读屏障（lfence）</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 当对被 volatile 修饰的成员变量或静态变量进行读操作时</span><br><span class="hljs-comment"> * 编译器会在该语句之前插入一条读屏障指令</span><br><span class="hljs-comment"> * 读屏障用于确保在该屏障之后，对所有共享变量的读取操作</span><br><span class="hljs-comment"> * 都能从主内存中获取最新的数据，避免读取到过期值</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 读屏障</span><br>    <span class="hljs-comment">// ready 是 volatile 变量</span><br>    <span class="hljs-keyword">if</span> (ready) &#123;<br>        num = num + num; <span class="hljs-comment">// num 是普通的共享变量，也加载的是主内存中的最新数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="1-2-2-2-synchronized-解决方案"><a href="#1-2-2-2-synchronized-解决方案" class="headerlink" title="1.2.2.2. synchronized 解决方案"></a>1.2.2.2. synchronized 解决方案</h5><p>synchronized 解决可见性的原理是：</p>
<ol>
<li>加锁：<ol>
<li>线程在获取锁之前，会先从主内存中读取共享变量的值，然后将其复制到线程的工作内存中，保证了线程获取锁时，使用的是主内存中的最新值。</li>
</ol>
</li>
<li>解锁：<ol>
<li>线程在释放锁之前，会将线程的工作内存中所有修改的共享变量刷新到主内存中。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// 锁对象</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">Lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">synchronized</span> (Lock) &#123;<br>                <span class="hljs-keyword">if</span> (!run) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t.start();<br><br>    sleep(<span class="hljs-number">1</span>);<br>    log.debug(<span class="hljs-string">&quot;停止 t&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (Lock) &#123;<br>        run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>synchronized 既能保证可见性，又能保证原子性，但缺点是 synchronized 是重量级操作，性能相对更低</li>
</ol>
</blockquote>
<hr>
<h6 id="1-2-2-2-1-✅-2-ReentrantLock-显式内存语义"><a href="#1-2-2-2-1-✅-2-ReentrantLock-显式内存语义" class="headerlink" title="1.2.2.2.1. ✅ 2. ReentrantLock + 显式内存语义"></a>1.2.2.2.1. ✅ 2. <strong>ReentrantLock + 显式内存语义</strong></h6><ul>
<li>虽然 <code>ReentrantLock</code> 本身也保证了加锁&#x2F;解锁的<strong>可见性</strong>，但更重要的是它可以通过 <code>lock()</code> 和 <code>unlock()</code> 方法建立<strong>happens-before</strong> 关系。</li>
</ul>
<blockquote>
<p>所以只要线程获取了锁，就可以看到<strong>之前持有锁的线程对共享变量的修改</strong>。</p>
</blockquote>
<hr>
<h6 id="1-2-2-2-2-✅-3-final-变量的安全发布"><a href="#1-2-2-2-2-✅-3-final-变量的安全发布" class="headerlink" title="1.2.2.2.2. ✅ 3. final 变量的安全发布"></a>1.2.2.2.2. ✅ 3. <strong>final 变量的安全发布</strong></h6><ul>
<li><code>final</code> 本身不保证可见性，但通过<strong>构造函数安全发布</strong>的方式（如通过不可变对象发布到线程共享结构中），可以避免重排序导致的可见性问题。</li>
</ul>
<hr>
<h6 id="1-2-2-2-3-✅-4-原子类（例如-AtomicInteger）"><a href="#1-2-2-2-3-✅-4-原子类（例如-AtomicInteger）" class="headerlink" title="1.2.2.2.3. ✅ 4. 原子类（例如 AtomicInteger）"></a>1.2.2.2.3. ✅ 4. <strong>原子类（例如 AtomicInteger）</strong></h6><ul>
<li><p><code>AtomicXXX</code> 类底层通过 <code>volatile</code> 实现可见性，同时通过 <strong>CAS + 内存屏障</strong> 实现原子性。</p>
</li>
<li><p><strong>适用场景</strong>：对数值进行原子更新时需要可见性</p>
</li>
</ul>
<hr>
<h6 id="1-2-2-2-4-✅-5-线程通信方法：wait-notify-、park-unpark"><a href="#1-2-2-2-4-✅-5-线程通信方法：wait-notify-、park-unpark" class="headerlink" title="1.2.2.2.4. ✅ 5. 线程通信方法：wait()&#x2F;notify()、park()&#x2F;unpark()"></a>1.2.2.2.4. ✅ 5. <strong>线程通信方法：wait()&#x2F;notify()、park()&#x2F;unpark()</strong></h6><ul>
<li><p><code>wait()</code> 会让线程释放锁并进入等待状态，<code>notify()</code> 唤醒线程。</p>
</li>
<li><p>这些方法<strong>依赖 synchronized 的可见性语义</strong>，所以线程醒来之后能看到共享变量的最新值。</p>
</li>
</ul>
<hr>
<h6 id="1-2-2-2-5-小结对比："><a href="#1-2-2-2-5-小结对比：" class="headerlink" title="1.2.2.2.5. 小结对比："></a>1.2.2.2.5. 小结对比：</h6><table>
<thead>
<tr>
<th>方法</th>
<th>可见性</th>
<th>原子性</th>
<th>有序性</th>
<th>是否加锁</th>
</tr>
</thead>
<tbody><tr>
<td><code>volatile</code></td>
<td>✅</td>
<td>❌</td>
<td>✅（禁止指令重排）</td>
<td>❌</td>
</tr>
<tr>
<td><code>synchronized</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>ReentrantLock</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><code>AtomicInteger</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌（基于 CAS）</td>
</tr>
<tr>
<td><code>wait/notify</code></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody></table>
<p>如果你关心的是<strong>写了之后别人能看到</strong>，<code>volatile</code>、锁、CAS 都是解决方案，但要选哪种，还得看是否也需要原子性、性能等其他考量。</p>
<p>需要我根据某种特定场景来推荐选择哪种方式吗？</p>
<h3 id="1-3-有序性"><a href="#1-3-有序性" class="headerlink" title="1.3. 有序性"></a>1.3. 有序性</h3><h4 id="1-3-1-有序性概述"><a href="#1-3-1-有序性概述" class="headerlink" title="1.3.1. 有序性概述"></a>1.3.1. 有序性概述</h4><p>有序性是指，程序的执行顺序与代码的先后顺序一致，以防止 CPU 进行指令重排所带来的不确定性。因为 JVM 在不影响程序最终正确性的前提下，可能会调整语句的实际执行顺序。例如，下面这段代码：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">static int a <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>static int b <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><br>static void main() &#123;<br>    a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>    b <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>从语义上看，先执行 <code>a = 1</code>，还是先执行 <code>b = 2</code>，并不会改变程序的最终结果。因此，这段代码的实际执行顺序既可以是：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>也可以是：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>这种行为称为<strong>指令重排</strong>。其本质目的是通过指令的重排序与组合，提升执行效率，实现指令级并行（流水线技术）。在单线程环境下，指令重排不会改变程序的执行结果，因此通常是安全的。</p>
<p>但在多线程场景下，指令重排可能会导致线程之间观察到的执行结果不一致，进而影响程序的正确性。因此，在并发编程中，我们需要确保指令重排不会破坏程序逻辑和线程之间的数据可见性，例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 可以重排的列子</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>System.out.<span class="hljs-built_in">println</span>(a + b);<br><br><br><span class="hljs-comment">// 不能重排的例子</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrencyTest</span> &#123;<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> ready = <span class="hljs-literal">false</span>;<br>    <br>	<span class="hljs-comment">// 一个线程执行这个</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ready) &#123;<br>            r.r1 = num + num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.r1 = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">// 一个线程执行这个</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">(I_Result r)</span> </span>&#123;<br>        num = <span class="hljs-number">3</span>;<br>        ready = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>[!NOTE] 注意事项</p>
<ol>
<li>上述代码在某些情况下可能输出结果为 0，这种现象通常只有在进行大量并发测试时才更容易复现，因此需要借助压测工具辅助观察。其根本原因在于，actor2 中的指令发生了重排，导致执行顺序被打乱：</li>
</ol>
</blockquote>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ready</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span><br><span class="hljs-attr">num</span> = <span class="hljs-number">3</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<hr>
<h4 id="1-3-2-有序性问题解决方案"><a href="#1-3-2-有序性问题解决方案" class="headerlink" title="1.3.2. 有序性问题解决方案"></a>1.3.2. 有序性问题解决方案</h4><h5 id="1-3-2-1-volatile-解决方案"><a href="#1-3-2-1-volatile-解决方案" class="headerlink" title="1.3.2.1. volatile 解决方案"></a>1.3.2.1. volatile 解决方案</h5><p>同样是为共享变量添加 volatile 关键字，既能够保证可见性，同时也能够禁止指令重排，其同样是基于读写屏障实现的。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 写屏障（sefence）</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 当对被 volatile 修饰的成员变量或静态变量进行写操作时</span><br><span class="hljs-comment"> * 编译器会在该语句之后插入一条写屏障指令</span><br><span class="hljs-comment"> * 写屏障用于确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor1</span><span class="hljs-params">()</span> </span>&#123;<br>    num = <span class="hljs-number">1</span>; <br>    ready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// ready 是 volatile 变量</span><br>    <span class="hljs-comment">// 写屏障</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> * 读屏障（lfence）</span><br><span class="hljs-comment"> * --------------------------------------------</span><br><span class="hljs-comment"> * 当对被 volatile 修饰的成员变量或静态变量进行读操作时</span><br><span class="hljs-comment"> * 编译器会在该语句之前插入一条读屏障指令</span><br><span class="hljs-comment"> * 读屏障用于确保指令重排序时，不会将读屏障之后的代码排在都屏障之前</span><br><span class="hljs-comment"> * ============================================</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">actor2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 读屏障</span><br>    <span class="hljs-comment">// ready 是 volatile 变量</span><br>    <span class="hljs-keyword">if</span> (ready) &#123;<br>        num = num + num;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  
    <span>></span>
    
  <a href="/categories/Java/Java-%E5%9F%BA%E7%A1%80/" class="category-chain-item">Java 基础</a>
  
  
    <span>></span>
    
  <a href="/categories/Java/Java-%E5%9F%BA%E7%A1%80/Java-Util-Concurrent%EF%BC%88JUC%EF%BC%89/" class="category-chain-item">Java Util Concurrent（JUC）</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>笔记：JUC</div>
      <div>https://wangjia5289.github.io/2025/05/18/笔记：JUC/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>霸天</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>May 18, 2025</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/05/28/%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A5%B6%E5%9D%97%E6%94%BB%E7%95%A5/" title="笔记：奶块攻略">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">笔记：奶块攻略</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/05/18/%E7%AC%94%E8%AE%B0%EF%BC%9ASpring%20Security/" title="笔记：Spring Security">
                        <span class="hidden-mobile">笔记：Spring Security</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  var relativeDate = function() {
    var updatedTime = document.getElementById('updated-time');
    if (updatedTime) {
      var text = updatedTime.textContent;
      var reg = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:Z|[+-]\d{2}:\d{2})/;
      var matchs = text.match(reg);
      if (matchs) {
        var relativeTime = moment(matchs[0]).fromNow();
        updatedTime.textContent = text.replace(reg, relativeTime);
      }
      updatedTime.style.display = '';
    }
  };
  Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/moment.min.js', function() {
    if (!'en'.startsWith('en')) {
      Fluid.utils.createScript('https://lib.baomitu.com/moment.js/2.29.4/locale/en.min.js', function() {
        relativeDate();
      });
    } else {
      relativeDate();
    }
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"display":{"superSample":2,"width":200,"height":350,"position":"left","hOffset":40,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":1,"opacityOnHover":0.5},"log":false});</script></body>
</html>
