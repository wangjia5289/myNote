---
title: 笔记：JVM
date: 2025-05-29
categories:
  - Java
  - Java 基础
  - Java Virtual Machine（JVM）
tags: 
author: 霸天
layout: post
---

## 1. 运行时数据区

### 1.1. 运行时数据区一览图

![](image-20250724223952607.png)

----


### 1.2. 程序计数器（PC 寄存器）

在 CPU 中，寄存器专门用于存储指令执行相关的现场信息，CPU 只有将数据加载到寄存器后才能执行指令。而在 JVM 中，PC 寄存器的全称是 Program Counter Register，中文通常译为 “程序计数器”，它是对物理寄存器的一种抽象。尽管名称相似，但它与物理 CPU 寄存器在功能上并不相同。

根据 JVM 规范，每个线程都拥有独立的、私有的程序计数器，其生命周期与线程一致，用于记录当前线程所执行方法中下一条将要执行的 JVM 字节码指令的地址（偏移量），由执行引擎负责读取指令并执行。如果执行的是本地方法（native），PC 的值为 `undefined`。

PC 寄存器是一块极小的内存区域，几乎可以忽略不计，因为它只需保存一个字节码指令的地址。在 32 位 JVM 中，通常使用 `int` 类型，占 4 个字节；而在 64 位 JVM 中，通常使用 `long` 类型，占 8 个字节。

![](image-20250722190040146.png)

- [ ] 
> [!NOTE] 注意事项
> 1. 程序计数器不会发生 GC，也不会抛出 OOM 或其他错误
> 2. PC 寄存器为什么不存在 GC？
> 	1. 在 JVM 创建线程时，会分配一块连续的内存区域，称为线程执行上下文，用于维护该线程的完整运行状态，包括 PC 寄存器、虚拟机栈、本地方法栈、线程本地存储以及线程状态等
> 	2. 当线程结束时，JVM 和操作系统会释放该线程所有相关的资源
> 3. PC 寄存器为什么不存在 OOM？
> 4. 为什么使用 PC 寄存器记录对应线程的执行地址？
> 	1. 由于 CPU 需要频繁切换不同线程，切换回来时必须知道从哪里继续执行，因此通过 PC 寄存器保存线程的执行地址，实现精确恢复
> 5. PC 寄存器中只记录偏移量，但你却说它 “用于记录当前线程所执行方法中下一条将要执行的 JVM 字节码指令的地址（偏移量）”，那它是如何确保这个偏移量一定对应的是 “当前方法” 的指令？
> 	1. 程序计数器只记录字节码数组中的偏移量，但它会配合 JVM 虚拟机栈中当前线程的栈顶栈帧，因为每个方法对应一个栈帧，最顶层的栈帧代表当前正在执行的方法。

---


### 1.3. 栈区

#### 1.3.1. 栈区一览图

![](图像清晰化.png)

----


#### 1.3.2. 栈区概述


> [!NOTE] 注意事项
> 1. 栈区不会发生 GC，但会抛出 OOM 或 StackOverflowError，常见有：
> 	1. OOM
> 		1. OutOfMemoryError: unable to create new native thread
> 			1. JVM 尝试创建新线程时，系统无法分配栈内存
> 	2. StackOverflowError
> 		1. 栈帧太多（比如递归没结束），导致栈空间“满了”


----




#### 1.3.3. 局部变量表

局部变量表是一个一维的数字数组，用于保存**方法参数**和**方法体内部定义的局部变量**。它可以存储多种数据类型，包括基本数据类型和对象引用（reference），在 JDK5 之前还包含一种 returnAddress 类型（了解即可）。

![](image-20250723142505659.png)

局部变量表中，最基本的存储单元称为变量槽（Slot）。JVM 会为每一个 Slot 分配一个访问索引（从 index 0 开始），通过这个索引可以访问到局部变量表中的变量。需要注意的是，索引不一定是连续递增 1，例如 long、double 类型会占用两个槽位。

其中，32 位及以内的数据类型（如：`reference`、`returnAddress`、`byte`、`short`、`char`、`int`、`float`、`boolean`）占用一个 Slot；**64 位的数据类型**（如：`long` 和 `double`）则占用两个 Slot。

![](image-20250723130746731.png)

> [!NOTE] 注意事项
> 1. `byte`、`short`、`char` 在存储进局部变量表前，会被自动转换为 `int` 类型，对应关系有：
> 	1. 原始类型 ---- 在局部变量表的类型
> 	2. byte ---- int
> 	3. short ---- int
> 	4. char ---- int
> 	5. int ---- int
> 	6. boolean ---- int
> 	7. long ----- long
> 	8. float ---- float
> 	9. double ---- double
> 2. 在栈帧中，与性能调优关系最为密切的部分就是局部变量表
> 3. 当方法调用结束后，该方法对应的栈帧会被销毁，局部变量表也随之销毁。
> 4. 局部变量表所需的容量大小在编译期间就已经确定，运行时无法更改。
> 5. 如果当前线程调用的方法是构造方法或实例方法，那么代表当前对象的引用 `this`（即堆中对象的引用地址）会默认存放在局部变量表 index 为 0 的槽中。这也解释了为什么我们在构造方法和实例方法中可以使用 `this`，而在 `static` 方法中却不能使用：
> 	1. 在下面的示例中，当执行 `main` 方法时，会创建一个栈帧；
> 	2. 执行 `Demo.staticMethod();` 时，由于是静态方法，属于类级别，可以直接调用；
> 	3. 执行 `Demo demo = new Demo();` 时，调用的是构造方法 `<init>`，此时会创建一个新的栈帧，并自动将 `this` 引用压入 index 为 0 的槽位中；当 `<init>` 方法执行完毕，会返回 `this`，赋值给变量 `demo`；
> 	4. 调用 `demo.instanceMethod();` 时，同样会创建一个栈帧，并将 `this` 引用压入 index 为 0 的槽位。
> 	5. 你可能会疑惑：调用 `new Demo()` 和 `demo.instanceMethod()` 的时候，代码里并没有传递 `this`，为什么 `this` 也能压入槽？其实这是 Java 的一种语法糖 + 字节码优化机制。虽然源码中没写，但在编译成字节码时，JVM 会自动将 `this` 作为第一个参数加入，如果方法声明为：`method(int a, int b, int c)`，实际上在实例方法中对应的局部变量表会是：`[this, a, b, c]`
```
public class Demo {

    public static void main(String[] args) {
        Demo.staticMethod();
        Demo demo = new Demo();
        demo.instanceMethod();
    }

    public static void staticMethod() {
        System.out.println("Static");
    }

    public void instanceMethod() {
        System.out.println("Instance");
    }
}
```

> [!NOTE] 注意事项
>4. 槽位是可以复用的。当某个局部变量生命周期结束（超出作用域）后，在其作用域之外声明的新局部变量很可能会复用这个已释放的槽位，从而达到节省局部变量表空间的目的
>	1. 例如，在下面的示例代码中，`b` 会复用 `a` 所占用的槽位。因此，整个方法的局部变量表最大只需要 2 个槽位
```
public class Test {  
    public static void main(String[] args) {  
        {  
            int a = 10;  
            System.out.println(a);  
        }  
  
        {  
            int b = 20;  
            System.out.println(b);  
        }  
    }  
}
```

> [!NOTE] 注意事项
>5. Java 类里各种变量的 “诞生” 与 “存活” 流程
>	1. 在下面的例子中，变量会经历以下几个阶段：
>		1. 类加载阶段
>			1. 准备阶段
>				1. JVM 将 `Demo.class` 文件加载到内存，并为静态变量 `staticVar` 分配内存，并赋予默认值 0
>				2. 该静态变量存储在方法区（元空间、Metaspace）（坏事了，jdk1.7 之前确实是方法区，jdk 1.8 之后是放到堆内存，直接放到老年代，那准备阶段对象都还没创建呢，啊对，静态变量与对象根本没关系，而是而是属于类本身的，不用等对象）
>				3. 准备阶段不执行任何代码，也不调用任何方法，只是为静态变量提供一个 “安全” 的初始状态，避免野指针或未定义行为。
>			2. 初始化阶段
>				1. 执行静态变量的显式赋值语句（如 `staticVar = 10;`）和静态代码块（`static {}`）中的代码。
>		2. 对象创建阶段
>			1. JVM 在堆内存中为对象 `demo` 分配空间，所有成员变量（如 `instanceVar`）都被分配内存并赋予默认值（0、false、null）
>			2. 然后执行构造方法，可以对成员变量进行显式初始化或逻辑处理。
>		3. 方法调用阶段
>			1. JVM 在栈内存中为方法调用创建一个新的栈帧
>			2. 因为是实例方法，槽位 0 用于存放 `this` 引用，指向当前调用方法的 `demo` 对象。
>			3. 槽位 1 用于存放方法参数 `param`，槽位 2 存放局部变量 `localVar`。
>			4. 需要注意的是，局部变量和方法参数不会像静态变量或成员变量那样自动初始化默认值。
>			5. 如果你只是声明了一个局部变量（如 `int localVar;`），但没有显式赋值（如 `localVar = 5`），那么就会编译报错。
```
public class Demo {

    // 静态变量（类变量）
    static int staticVar = 10;

    // 成员变量（实例变量）
    int instanceVar;
    
	// 方法参数
    public void method(int param) {
    
	    // 局部变量
        int localVar = 5;
        
        System.out.println(localVar);
    }
}
```

----


#### 1.3.4. 操作数栈

##### 1.3.4.1. 操作数栈概述

操作数栈是 JVM 执行引擎的一个工作区，会根据方法中的字节码指令，向栈中写入数据或提取数据，这些操作被称为入栈和出栈。它主要用于保存计算过程中的中间结果，同时作为变量的临时存储空间。

我们常说 Java 虚拟机的解释引擎是基于栈的执行引擎，这里的 “栈” 指的就是操作数栈。

需要注意的是，操作数栈是通过数组实现的栈结构，而**不是链表**，而且虽然它是基于数组实现的，但我们在设计时不应使用数组的随机访问等方法，而应遵循栈的操作特性，仅使用入栈和出栈操作。

下面用详细代码进行举例：
```
public class Test {

    public static void main(String[] args) {
        int i = 15;
        int j = 8;
        int k = i + j;
    }
	
}
```


<font color="#92d050">1. 指令地址 0</font>
![](image-20250723180139005.png)

> [!NOTE] 注意事项
> 1. 数据压入操作数栈后，类型依旧遵循以下规则：
> 	1. 原始类型 ---- 在局部变量表的类型
> 	2. byte ---- int
> 	3. short ---- int
> 	4. char ---- int
> 	5. int ---- int
> 	6. boolean ---- int
> 	7. long ----- long
> 	8. float ---- float
> 	9. double ---- double
> 2. 32 位及以内的数据类型（如：`reference`、`returnAddress`、`byte`、`short`、`char`、`int`、`float`、`boolean`）占用一个栈单位深度；64 位的数据类型（如：`long` 和 `double`）则占用两个栈单位深度。
> 3. 与局部变量表一致，操作数栈最大深度在编译期间就已经确定，运行时无法更改（栈顶缓存技术不会影响最大深度）


<font color="#92d050">2. 指令地址 2</font>
![](image-20250723180026214.png)


<font color="#92d050">3. 指令地址 3 </font>
![](image-20250723180216377.png)


<font color="#92d050">4. 指令地址 5</font>
![](image-20250723180252011.png)


<font color="#92d050">5. 指令地址 6</font>
![](image-20250723180343374.png)


<font color="#92d050">6. 指令地址 7</font>
![](image-20250723180532258.png)


<font color="#92d050">7. 指令地址 8</font>
![](image-20250723180621968.png)


<font color="#92d050">8. 指令地址 9</font>
![](image-20250723180737908.png)

> [!NOTE] 注意事项
> 1. 在该方法中，最多仅有两个操作数同时存在于操作数栈中，因此操作数栈最大深度为 2


<font color="#92d050">9. 最终效果</font>
![](image-20250723173022583.png)

---


##### 1.3.4.2. 栈顶缓存技术

JVM 是基于栈的架构，它不像物理 CPU 那样通过寄存器来存放操作数并参与计算，而是依赖操作数栈（Operand Stack）来完成大部分运算。因此，JVM 的指令通常不携带操作数，比如 `iadd`（整数加法）会默认从栈顶弹出两个数，相加后再将结果压回栈中，使字节码更加简洁紧凑。

这种设计虽然带来了跨平台性强、字节码体积小、指令格式简单等优点，但也引入了性能问题：所有操作都依赖栈，频繁的入栈、出栈操作会导致大量内存访问，从而拖慢指令执行速度。一次简单的加法可能需要经历 `load → push → push → iadd → store` 的多个步骤，而不像寄存器架构那样仅需一条指令。此外，每次入栈和出栈本质上都是对 JVM 内存结构（即栈帧中的操作数栈区域）的访问，而内存访问速度远不如 CPU 寄存器。

为了解决这一问题，HotSpot JVM 的设计者提出了栈顶缓存（ToS，Top-of-Stack Caching）技术，将操作数栈顶部的若干个元素缓存在 CPU 寄存器中，以减少对操作数栈内存的频繁访问，从而提升执行引擎的整体执行效率。

在解释执行阶段，字节码逐条执行，大部分值都直接读写内存中的操作数栈，寄存器的使用非常有限（仅用于短暂调度）。而当某个方法成为热点，触发 JIT 编译后，**JIT 编译器**会在生成本地机器码的过程中启用栈顶缓存技术，将栈顶的值尽可能缓存在寄存器中。

然而，由于硬件本身的限制，寄存器数量十分有限。以常见的 x86 架构为例，通用寄存器仅有 8 个（`eax`、`ebx`、`ecx`、`edx`、`esi`、`edi`、`ebp`、`esp`），即便是现代的 x86-64 架构也只有 16 个。这些寄存器还需要被用于局部变量、参数传递等其他任务，因此必须通过非常严格的寄存器分配与抢占策略进行管理。这也正是栈顶缓存技术只被应用于热点方法，而非所有方法的原因。并且寄存器能够缓存的数据非常有限，但通常只缓存 2~4 个槽位就已能显著提升性能。

需要注意的是，只有在必要的场景下，寄存器中的数据才会被同步回栈内存（即先存入 CPU 寄存器，必要时才写回内存中的操作数栈）：
1. 调用方法前
	1. 如果要调用某个方法，而该方法需要从栈顶获取参数，就必须先将寄存器中的值写回栈内存，确保方法调用机制能按照字节码协议正确读取参数
2. 操作数栈溢出时
	1. 当需要缓存的栈顶数据超过寄存器容量时，旧数据必须写回栈中，以腾出寄存器空间
3. 数据生命周期结束前的检查
	1. 如果某个值在之后不会再使用，为了保持字节码语义的正确性（如异常处理或 GC 根节点扫描），可能会提前将其写回栈中
4. 调试 / 异常机制介入时
	1. 当调试器需要访问栈上值，或在发生异常抛出、栈回溯等情况下，JVM 需还原执行现场，也必须将寄存器中的值同步回操作数栈

----


#### 1.3.5. 动态链接

---

#### 栈区异常示例

---



### 1.4. 堆区

#### 堆区一览图

![](image-20250725114229098.png)

----


#### 堆区概述

在一个 JVM 实例中，只存在一块堆内存，堆是 Java 内存管理的核心区域，也是整个内存结构中最大的一块，几乎所有的对象实例和数组，在运行时都会被分配到堆上（需考虑逃逸分析的优化可能），Java 堆是所有线程共享的（但需考虑线程私有的 TLAB 缓冲区机制）。



有意思：数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。


> [!NOTE] 注意事项
> 1. 堆区既会发生 GC，也会抛出 OOM，常见有：
> 	1. OutOfMemoryError: Java heap space
> 		1. 堆内存空间不足，无法为新对象分配内存
> 	2. OutOfMemoryError: GC overhead limit exceeded
> 		1. 垃圾回收耗时过长且回收效果极差，JVM 为避免长时间卡顿而主动抛出异常
> 	3. OutOfMemoryError: Requested array size exceeds VM limit
> 		1. 尝试分配超出虚拟机限制的超大数组，导致分配失败
> 2. 为什么要在堆区分代？
> 	1. IBM 公司的专门研究表明，新生代中 80% 的对象都是 “朝生夕死” 的
> 3. 虽然堆在物理上可以是不连续的内存空间，但从逻辑上应视为一个连续的整体。
> 4. Java 堆区在 JVM 启动时被创建，其空间大小也在此时初始化。但不同于局部变量表和操作数栈，堆区的大小可以通过 JVM 参数手动指定，包括初始空间和最大空间，且在运行时具有动态扩展能力：当前堆空间不足，但尚未达到最大限制时，JVM 会尝试扩大堆空间，同时通常也会触发一次垃圾回收（GC），GC 部分详见下文：垃圾回收（GC）
> 	1. -Xms：用于设置堆区的初始内存大小。例如：java -Xms512m YourApp
> 		1. 常用单位有：k、m、g
> 	2. -Xmx：用于设置堆区的最大内存大小。例如：java -Xmx2048m YourApp
> 	3. 实际使用中，通常将 -Xms 和 -Xmx 设置为相同的值，目的是为了避免 JVM 在运行期间，频繁触发 堆空间扩容与内存结构重计算以及其触发的GC
> 		1. 堆空间扩容与内存结构重计算
> 			1. 当 GC 之后依然无法满足内存申请，JVM 会尝试扩展堆内存至更高值，同时可能重新计算内存布局（如 Eden/Survivor 的比例划分），这是一种昂贵的操作
> 		2. 垃圾回收（GC）
> 			1. 在堆空间不足时触发，试图清理无用对象以释放内存。
> 			2. 详见下文：垃圾回收（GC）
> 	4. 默认情况下（以 HotSpot JVM 为例）
> 		1. 初始堆内存大小（-Xms）默认为物理内存的 1/64；
> 		2. 最大堆内存大小（-Xmx）默认为物理内存的 1/4；
> 5. 堆区常用的 JVM 参数有：
> 	1. -Xms
> 		1. 用于设置堆区的初始内存大小。
> 		2. 例如：java -Xms512m YourApp
> 		3. 常用单位有：k、m、g
> 	2. -Xmx
> 		1. 用于设置堆区的最大内存大小。
> 		2. 例如：java -Xmx2048m YourApp
> 		3. 实际使用中，通常将 -Xms 和 -Xmx 设置为相同的值
> 	3. -XX:NewRatio=2
> 		1. 用于配置新生代与老年代在堆区的占比。
> 		2. 例如：java -XX:NewRatio=2 MyApp，表示新生代占堆区的 1/3，老年代占堆区的 2/3
> 	4. -XX:SurvivorRatio=8
> 		1. 用于配置 Eden 区与 Survivor 区在新生代的占比。
> 		2. 例如：java -Xmn100m -XX:SurvivorRatio=8 MyApp，表示 Eden : Survivor0 : Survivor1 = 8 : 1 : 1
> 	5. -XX:MaxTenuringThreshold=15
> 		1. 用于配置对象存活年龄
> 			1. 例如：java -XX:MaxTenuringThreshold=15。
> 	6. -XX:±UseTLAB
> 		1. 用于配置是否开启 TLAB
> 		2. 例如：java -XX:+UseTLAB -XX:+PrintTLAB MyApp
> 	7. -XX:±PrintTLAB
> 		1. 用于打印 TLAB 分配和使用情况
> 		2. 例如：java -XX:+UseTLAB -XX:+PrintTLAB MyApp
> 	8. -XX:TLABWasteTargetPercent=50




#### 堆区异常示例

----


## 方法区




















## 垃圾回收（GC）

### GC 概述


> [!NOTE] 注意事项
> 1. GC 常用的 JVM 参数有：
> 	1. -XX:±PrintGCDetails







































