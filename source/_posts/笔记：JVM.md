---
title: 笔记：JVM
date: 2025-05-29
categories:
  - Java
  - Java 基础
  - Java Virtual Machine（JVM）
tags: 
author: 霸天
layout: post
---

## 运行时数据区

### 一览图

![](提高图片清晰度%20(1).png)

----


### 程序计数器（PC 寄存器）

在 CPU 中，寄存器专门用于存储指令执行相关的现场信息，CPU 只有将数据加载到寄存器后才能执行指令。而在 JVM 中，PC 寄存器的全称是 Program Counter Register，中文通常译为 “程序计数器”，它是对物理寄存器的一种抽象。尽管名称相似，但它与物理 CPU 寄存器在功能上并不相同。

根据 JVM 规范，每个线程都拥有独立的、私有的程序计数器，其生命周期与线程一致，用于记录当前线程所执行方法中下一条将要执行的 JVM 字节码指令的地址（偏移量），由执行引擎负责读取指令并执行。如果执行的是本地方法（native），PC 的值为 `undefined`。

PC 寄存器是一块极小的内存区域，几乎可以忽略不计，因为它只需保存一个字节码指令的地址。在 32 位 JVM 中，通常使用 `int` 类型，占 4 个字节；而在 64 位 JVM 中，通常使用 `long` 类型，占 8 个字节。

需要注意的是，程序计数器不存在 GC，也不存在 OOM

![](image-20250722190040146.png)

- [ ] 
> [!NOTE] 注意事项：
> 1. PC 寄存器为什么不存在 GC？
> 	1. 在 JVM 创建线程时，会分配一块连续的内存区域，称为线程执行上下文，用于维护该线程的完整运行状态，包括 PC 寄存器、虚拟机栈、本地方法栈、线程本地存储以及线程状态等
> 	2. 当线程结束时，JVM 和操作系统会释放该线程所有相关的资源
> 2. PC 寄存器为什么不存在 OOM？
> 3. 为什么将 PC 寄存器设置为线程私有？
> 	1. 为了准确记录每个线程当前正在执行的字节码指令地址，最合理的做法是为每个线程分配独立的 PC 寄存器
> 4. 为什么使用 PC 寄存器记录对应线程的执行地址？
> 	1. 由于 CPU 需要频繁切换不同线程，切换回来时必须知道从哪里继续执行，因此通过 PC 寄存器保存线程的执行地址，实现精确恢复
> 5. PC 寄存器中只记录偏移量，但你却说它 “用于记录当前线程所执行方法中下一条将要执行的 JVM 字节码指令的地址（偏移量）”，那它是如何确保这个偏移量一定对应的是 “当前方法” 的指令？
> 	1. 程序计数器只记录字节码数组中的偏移量，但它会配合 JVM 虚拟机栈中当前线程的栈顶栈帧，因为每个方法对应一个栈帧，最顶层的栈帧代表当前正在执行的方法。


---


### 虚拟机栈

#### 虚拟机栈概述

![](图像清晰化.png)

---


#### 局部变量表

局部变量表是一个一维的数字数组，用于保存方法参数和方法体内部定义的局部变量。它可以存储多种数据类型，包括基本数据类型和对象引用（reference），在 JDK5 之前还包含一种 returnAddress 类型（了解即可）。

![](image-20250723142505659.png)

局部变量表中，最基本的存储单元称为变量槽（Slot）。JVM 会为每一个 Slot 分配一个访问索引（从 index 0 开始），通过这个索引可以访问到局部变量表中的变量。需要注意的是，索引不一定是连续递增 1，例如 long、double 类型会占用两个槽位。

其中，32 位及以内的数据类型（如：`reference`、`returnAddress`、`byte`、`short`、`char`、`int`、`float`、`boolean`）占用一个 Slot；**64 位的数据类型**（如：`long` 和 `double`）则占用两个 Slot。

![](image-20250723130746731.png)

> [!NOTE] 注意事项
> 1. `byte`、`short`、`char` 在存储进局部变量表前，会被自动转换为 `int` 类型，对应关系有：
> 	1. 原始类型 ---- 在局部变量表的类型
> 	2. byte ---- int
> 	3. short ---- int
> 	4. char ---- int
> 	5. int ---- int
> 	6. boolean ---- int
> 	7. long ----- long
> 	8. float ---- float
> 	9. double ---- double
> 2. 在栈帧中，与性能调优关系最为密切的部分就是局部变量表
> 3. 当方法调用结束后，该方法对应的栈帧会被销毁，局部变量表也随之销毁。
> 4. 局部变量表所需的容量大小在编译期间就已经确定，运行时无法更改。
> 5. 如果当前线程调用的方法是构造方法或实例方法，那么代表当前对象的引用 `this`（即堆中对象的引用地址）会默认存放在局部变量表 index 为 0 的槽中。这也解释了为什么我们在构造方法和实例方法中可以使用 `this`，而在 `static` 方法中却不能使用：
> 	1. 在下面的示例中，当执行 `main` 方法时，会创建一个栈帧；
> 	2. 执行 `Demo.staticMethod();` 时，由于是静态方法，属于类级别，可以直接调用；
> 	3. 执行 `Demo demo = new Demo();` 时，调用的是构造方法 `<init>`，此时会创建一个新的栈帧，并自动将 `this` 引用压入 index 为 0 的槽位中；当 `<init>` 方法执行完毕，会返回 `this`，赋值给变量 `demo`；
> 	4. 调用 `demo.instanceMethod();` 时，同样会创建一个栈帧，并将 `this` 引用压入 index 为 0 的槽位。
> 	5. 你可能会疑惑：调用 `new Demo()` 和 `demo.instanceMethod()` 的时候，代码里并没有传递 `this`，为什么 `this` 也能压入槽？其实这是 Java 的一种语法糖 + 字节码优化机制。虽然源码中没写，但在编译成字节码时，JVM 会自动将 `this` 作为第一个参数加入，如果方法声明为：`method(int a, int b, int c)`，实际上在实例方法中对应的局部变量表会是：`[this, a, b, c]`
```
public class Demo {

    public static void main(String[] args) {
        Demo.staticMethod();
        Demo demo = new Demo();
        demo.instanceMethod();
    }

    public static void staticMethod() {
        System.out.println("Static");
    }

    public void instanceMethod() {
        System.out.println("Instance");
    }
}
```

> [!NOTE] 注意事项
>4. 槽位是可以复用的。当某个局部变量生命周期结束（超出作用域）后，在其作用域之外声明的新局部变量很可能会复用这个已释放的槽位，从而达到节省局部变量表空间的目的
>	1. 例如，在下面的示例代码中，`b` 会复用 `a` 所占用的槽位。因此，整个方法的局部变量表最大只需要 2 个槽位
```
public class Test {  
    public static void main(String[] args) {  
        {  
            int a = 10;  
            System.out.println(a);  
        }  
  
        {  
            int b = 20;  
            System.out.println(b);  
        }  
    }  
}
```

> [!NOTE] 注意事项
>5. Java 类里各种变量的 “诞生” 与 “存活” 流程
>	1. 在下面的例子中，变量会经历以下几个阶段：
>		1. 类加载阶段
>			1. 准备阶段
>				1. JVM 将 `Demo.class` 文件加载到内存，并为静态变量 `staticVar` 分配内存，并赋予默认值 0
>				2. 该静态变量存储在方法区（元空间、Metaspace）
>				3. 准备阶段不执行任何代码，也不调用任何方法，只是为静态变量提供一个 “安全” 的初始状态，避免野指针或未定义行为。
>			2. 初始化阶段
>				1. 执行静态变量的显式赋值语句（如 `staticVar = 10;`）和静态代码块（`static {}`）中的代码。
>		2. 对象创建阶段
>			1. JVM 在堆内存中为对象 `demo` 分配空间，所有成员变量（如 `instanceVar`）都被分配内存并赋予默认值（0、false、null）
>			2. 然后执行构造方法，可以对成员变量进行显式初始化或逻辑处理。
>		3. 方法调用阶段
>			1. JVM 在栈内存中为方法调用创建一个新的栈帧
>			2. 因为是实例方法，槽位 0 用于存放 `this` 引用，指向当前调用方法的 `demo` 对象。
>			3. 槽位 1 用于存放方法参数 `param`，槽位 2 存放局部变量 `localVar`。
>			4. 需要注意的是，局部变量和方法参数不会像静态变量或成员变量那样自动初始化默认值。
>			5. 如果你只是声明了一个局部变量（如 `int localVar;`），但没有显式赋值（如 `localVar = 5`），那么就会编译报错。
```
public class Demo {

    // 静态变量（类变量）
    static int staticVar = 10;

    // 成员变量（实例变量）
    int instanceVar;
    
	// 方法参数
    public void method(int param) {
    
	    // 局部变量
        int localVar = 5;
        
        System.out.println(localVar);
    }
}
```

----


#### 操作数栈

操作数栈是 JVM 执行引擎的一个工作区，会根据方法中的字节码指令，向栈中写入数据或提取数据，这些操作被称为入栈和出栈。它主要用于保存计算过程中的中间结果，同时作为变量的临时存储空间。

我们常说 Java 虚拟机的解释引擎是基于栈的执行引擎，这里的 “栈” 指的就是操作数栈。

需要注意的是，操作数栈是通过数组实现的栈结构，而**不是链表**。而且虽然它是基于数组实现的，但我们在设计时不应使用数组的随机访问等方法，而应遵循栈的操作特性，仅使用入栈和出栈操作。

下面用详细代码进行举例：
```
public class Test {

    public static void main(String[] args) {
        int i = 15;
        int j = 8;
        int k = i + j;
    }
	
}
```


<font color="#92d050">1. 指令地址 0</font>
![](image-20250723180139005.png)

> [!NOTE] 注意事项
> 1. 数据压入操作数栈后，类型依旧遵循以下规则：
> 	1. 原始类型 ---- 在局部变量表的类型
> 	2. byte ---- int
> 	3. short ---- int
> 	4. char ---- int
> 	5. int ---- int
> 	6. boolean ---- int
> 	7. long ----- long
> 	8. float ---- float
> 	9. double ---- double


<font color="#92d050">2. 指令地址 2</font>
![](image-20250723180026214.png)


<font color="#92d050">3. 指令地址 3 </font>
![](image-20250723180216377.png)


<font color="#92d050">4. 指令地址 5</font>
![](image-20250723180252011.png)


<font color="#92d050">5. 指令地址 6</font>
![](image-20250723180343374.png)


<font color="#92d050">6. 指令地址 7</font>
![](image-20250723180532258.png)


<font color="#92d050">7. 指令地址 8</font>
![](image-20250723180621968.png)


<font color="#92d050">8. 指令地址 9</font>
![](image-20250723180737908.png)

> [!NOTE] 注意事项
> 1. 在该方法中，最多仅有两个操作数同时存在于操作数栈中，因此操作数栈最大深度为 2


<font color="#92d050">9. 最终效果</font>
![](image-20250723173022583.png)



---
















